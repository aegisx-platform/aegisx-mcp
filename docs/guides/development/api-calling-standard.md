---
title: 'API Calling Standard'
description: 'Correct URL patterns and API calling conventions'
category: guides
tags: [development, api, standards]
---

# API Calling Standard

> **MANDATORY: How to call APIs correctly in AegisX Platform**

## ğŸ“‹ Overview

AegisX uses a **standardized API calling pattern** with automatic `/api` prefix handling. All developers MUST follow this standard to ensure consistency across the codebase.

## ğŸ—ï¸ How It Works

### Architecture Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Angular Service                                               â”‚
â”‚    this.http.post('/auth/login', ...)                           â”‚
â”‚    URL: /auth/login                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. BaseUrlInterceptor (Automatic)                                â”‚
â”‚    Adds /api prefix for relative URLs                            â”‚
â”‚    URL: /auth/login â†’ /api/auth/login                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Development Proxy (proxy.conf.js)                             â”‚
â”‚    Routes /api/* to backend                                       â”‚
â”‚    URL: /api/auth/login â†’ http://localhost:3333/api/auth/login  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Backend API (Fastify)                                         â”‚
â”‚    Receives: POST http://localhost:3333/api/auth/login          â”‚
â”‚    Routes: /api/auth/login                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“– Service Implementation Examples

### Authentication Service

```typescript
@Injectable({ providedIn: 'root' })
export class AuthService {
  private http = inject(HttpClient);

  // âœ… CORRECT: Use relative URLs without /api prefix
  login(credentials: LoginRequest): Observable<AuthResponse> {
    return this.http.post<AuthResponse>('/auth/login', credentials);
  }

  register(userData: RegisterRequest): Observable<AuthResponse> {
    return this.http.post<AuthResponse>('/auth/register', userData);
  }

  logout(): Observable<any> {
    return this.http.post('/auth/logout', {});
  }

  getProfile(): Observable<User> {
    return this.http.get<User>('/profile');
  }

  refreshToken(refreshToken: string): Observable<AuthResponse> {
    return this.http.post<AuthResponse>('/auth/refresh', { refreshToken });
  }
}
```

### User Service

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);

  // âœ… CORRECT: All CRUD operations without /api prefix
  getUsers(params?: any): Observable<PagedResponse<User>> {
    return this.http.get<PagedResponse<User>>('/users', { params });
  }

  getUser(id: string): Observable<User> {
    return this.http.get<User>(`/users/${id}`);
  }

  createUser(data: CreateUserDto): Observable<User> {
    return this.http.post<User>('/users', data);
  }

  updateUser(id: string, data: UpdateUserDto): Observable<User> {
    return this.http.put<User>(`/users/${id}`, data);
  }

  deleteUser(id: string): Observable<void> {
    return this.http.delete<void>(`/users/${id}`);
  }
}
```

### CRUD Generator Pattern

```typescript
// Generated by aegisx-crud
@Injectable({ providedIn: 'root' })
export class BooksService {
  private http = inject(HttpClient);
  private readonly apiUrl = '/books'; // âœ… CORRECT: No /api prefix

  findAll(params?: any): Observable<PagedResponse<Book>> {
    return this.http.get<PagedResponse<Book>>(this.apiUrl, { params });
  }

  findOne(id: string): Observable<Book> {
    return this.http.get<Book>(`${this.apiUrl}/${id}`);
  }

  create(data: CreateBookDto): Observable<Book> {
    return this.http.post<Book>(this.apiUrl, data);
  }

  update(id: string, data: UpdateBookDto): Observable<Book> {
    return this.http.put<Book>(`${this.apiUrl}/${id}`, data);
  }

  remove(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }
}
```

## ğŸ›ï¸ Layer-Based Routing (Platform vs Domain)

AegisX uses a **two-layer routing architecture** to separate shared platform resources from domain-specific business logic.

### Architecture Overview

```
Backend API Structure:
â”œâ”€â”€ Platform Layer (/v1/platform/*)
â”‚   â”œâ”€â”€ departments     â† Shared across all domains
â”‚   â”œâ”€â”€ users           â† User management (shared)
â”‚   â”œâ”€â”€ rbac/*          â† Role-based access control (shared)
â”‚   â””â”€â”€ settings        â† System settings (shared)
â”‚
â””â”€â”€ Domain Layer (/{domain}/*)
    â”œâ”€â”€ inventory/master-data/*    â† Inventory-specific master data
    â”œâ”€â”€ inventory/operations/*     â† Inventory operations
    â”œâ”€â”€ inventory/budget/*         â† Budget management
    â””â”€â”€ hr/*                       â† HR domain (future)
```

### Routing Decision Matrix

| Resource Type | Characteristics               | Correct Layer  | Endpoint Pattern                                    |
| ------------- | ----------------------------- | -------------- | --------------------------------------------------- |
| **Platform**  | Shared across all domains     | Platform Layer | `/v1/platform/{resource}`                           |
|               | Organization structure        |                | Example: `/v1/platform/departments`                 |
|               | User management               |                | Example: `/v1/platform/users`                       |
|               | RBAC resources                |                | Example: `/v1/platform/rbac/roles`                  |
| **Domain**    | Business-specific             | Domain Layer   | `/{domain}/{section}/{resource}`                    |
|               | Unique to one domain          |                | Example: `/inventory/master-data/drugs`             |
|               | Not shared with other domains |                | Example: `/inventory/operations/budget-allocations` |

### Platform Layer Examples

**âœ… CORRECT: Platform resources use `/v1/platform/*`**

```typescript
// Departments Service (shared resource)
@Injectable({ providedIn: 'root' })
export class DepartmentService {
  private http = inject(HttpClient);
  private baseUrl = '/v1/platform/departments'; // âœ… Platform Layer

  getAll(): Observable<Department[]> {
    return this.http.get<Department[]>(this.baseUrl);
  }
}

// Users Service (shared resource)
@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);
  private baseUrl = '/v1/platform/users'; // âœ… Platform Layer

  getAll(): Observable<User[]> {
    return this.http.get<User[]>(this.baseUrl);
  }
}

// RBAC Service (shared resource)
@Injectable({ providedIn: 'root' })
export class RbacService {
  private http = inject(HttpClient);
  private baseUrl = '/v1/platform/rbac'; // âœ… Platform Layer

  getRoles(): Observable<Role[]> {
    return this.http.get<Role[]>(`${this.baseUrl}/roles`);
  }
}
```

### Domain Layer Examples

**âœ… CORRECT: Domain-specific resources use `/{domain}/*`**

```typescript
// Drugs Service (inventory-specific)
@Injectable({ providedIn: 'root' })
export class DrugsService {
  private http = inject(HttpClient);
  private baseUrl = '/inventory/master-data/drugs'; // âœ… Domain Layer

  getAll(): Observable<Drug[]> {
    return this.http.get<Drug[]>(this.baseUrl);
  }
}

// Budget Allocations Service (inventory operations)
@Injectable({ providedIn: 'root' })
export class BudgetAllocationsService {
  private http = inject(HttpClient);
  private baseUrl = '/inventory/operations/budget-allocations'; // âœ… Domain Layer

  getAll(): Observable<BudgetAllocation[]> {
    return this.http.get<BudgetAllocation[]>(this.baseUrl);
  }
}

// Budget Requests Service (inventory subdomain)
@Injectable({ providedIn: 'root' })
export class BudgetRequestsService {
  private http = inject(HttpClient);
  private baseUrl = '/inventory/budget/budget-requests'; // âœ… Domain Layer

  getAll(): Observable<BudgetRequest[]> {
    return this.http.get<BudgetRequest[]>(this.baseUrl);
  }
}
```

### Common Mistakes

**âŒ WRONG: Using Domain Layer for shared resources**

```typescript
// departments should be Platform Layer (shared resource)
@Injectable({ providedIn: 'root' })
export class DepartmentService {
  private baseUrl = '/inventory/master-data/departments'; // âŒ WRONG!
  // This returns 404 because departments is a platform resource
}
```

**âœ… CORRECT: Use Platform Layer for shared resources**

```typescript
@Injectable({ providedIn: 'root' })
export class DepartmentService {
  private baseUrl = '/v1/platform/departments'; // âœ… CORRECT!
}
```

### How to Choose the Correct Layer

**Ask these questions:**

1. **Is this resource shared across multiple domains?**
   - Yes â†’ Platform Layer (`/v1/platform/*`)
   - No â†’ Domain Layer (`/{domain}/*`)

2. **Is this organizational structure or system configuration?**
   - Yes â†’ Platform Layer (departments, users, roles, settings)
   - No â†’ Domain Layer (drugs, budgets, inventory)

3. **Does this resource belong to a specific business domain?**
   - Yes â†’ Domain Layer (`/inventory/*`, `/hr/*`)
   - No â†’ Platform Layer

**Examples:**

| Resource           | Shared? | System Config? | Domain-Specific?   | Correct Layer                                      |
| ------------------ | ------- | -------------- | ------------------ | -------------------------------------------------- |
| Departments        | âœ… Yes  | âœ… Yes         | âŒ No              | Platform: `/v1/platform/departments`               |
| Users              | âœ… Yes  | âœ… Yes         | âŒ No              | Platform: `/v1/platform/users`                     |
| Roles              | âœ… Yes  | âœ… Yes         | âŒ No              | Platform: `/v1/platform/rbac/roles`                |
| Drugs              | âŒ No   | âŒ No          | âœ… Yes (Inventory) | Domain: `/inventory/master-data/drugs`             |
| Budgets            | âŒ No   | âŒ No          | âœ… Yes (Inventory) | Domain: `/inventory/master-data/budgets`           |
| Budget Allocations | âŒ No   | âŒ No          | âœ… Yes (Inventory) | Domain: `/inventory/operations/budget-allocations` |

### Integration Example: Components Using Services

**Budget Requests Form using Platform departments:**

```typescript
@Component({
  selector: 'app-budget-requests-form',
  // ...
})
export class BudgetRequestFormComponent implements OnInit {
  private departmentService = inject(DepartmentService); // Platform Layer service

  departments = signal<Department[]>([]);

  async ngOnInit() {
    // Load departments from Platform Layer
    await this.departmentService.loadDepartmentList({ limit: 100 });
    const departmentsList = this.departmentService.departmentsList();
    this.departments.set(departmentsList);
  }
}
```

**Key Takeaway:** Components should use services (not direct HTTP calls), and services should use the correct layer based on the resource type.

## ğŸ“š Reference: Swagger/OpenAPI Documentation

**Development:** `http://127.0.0.1:3333/documentation`
**JSON Spec:** `http://127.0.0.1:3333/documentation/json`

### How to Use Swagger Docs

**1. Find Available Endpoints:**

```bash
# List all endpoints
curl -s http://127.0.0.1:3333/documentation/json | jq -r '.paths | keys[]'

# Example output:
# /api/auth/login
# /api/auth/register
# /api/users
# /api/users/{id}
```

**2. Check Endpoint Details:**

```bash
# Get specific endpoint info
curl -s http://127.0.0.1:3333/documentation/json | \
  jq '.paths["/api/auth/login"]'
```

**3. Service Implementation from Swagger:**

**Step 1:** Find endpoint in Swagger (e.g., `/api/auth/login`)
**Step 2:** Remove `/api` prefix: `/api/auth/login` â†’ `/auth/login`
**Step 3:** Use in service:

```typescript
// From Swagger: POST /api/auth/login
// In service: POST /auth/login
this.http.post('/auth/login', credentials);
```

## ğŸ” Debugging API Calls

### Enable Debug Logging

**Temporary debugging:**

```typescript
// In base-url.interceptor.ts
if (!environment.production) {
  console.log(`[BaseUrlInterceptor] ${req.method} ${req.url} â†’ ${apiReq.url}`);
}
```

**Network tab inspection:**

1. Open Chrome DevTools (F12)
2. Go to Network tab
3. Filter: `XHR` or `Fetch`
4. Check request URL, headers, body

**Expected URLs:**

```
Development:
  Request:  POST http://localhost:4200/api/auth/login
  Proxied:  POST http://localhost:3333/api/auth/login

Production:
  Request:  POST https://yourdomain.com/api/auth/login
  Backend:  Same domain
```

### Common Debug Scenarios

**Problem:** API call returns 404

```bash
# Check 1: Verify endpoint exists in Swagger
curl -s http://127.0.0.1:3333/documentation/json | \
  jq -r '.paths | keys[]' | grep "users"

# Check 2: Verify URL format
# Service: /users
# Interceptor: /api/users
# Proxy: http://localhost:3333/api/users
```

**Problem:** CORS errors

```bash
# Check 1: Verify proxy is running
# Development: proxy.conf.js should handle CORS

# Check 2: Check proxy logs
# Should see: [HPM] Proxy created: /api -> http://localhost:3333
```

**Problem:** Double `/api/api/` prefix

```bash
# Root cause: Service has /api prefix already
# Fix: Remove /api from service URL
# Before: this.http.get('/api/users')
# After:  this.http.get('/users')
```

## ğŸš€ Production Deployment

### URL Resolution in Production

**Development:**

```
Frontend:  http://localhost:4200
API:       http://localhost:3333
Proxy:     Routes /api -> http://localhost:3333/api
```

**Production:**

```
Frontend:  https://yourdomain.com
API:       https://yourdomain.com/api (same domain)
No proxy:  Browser directly calls /api endpoints
```

**Environment-specific behavior:**

```typescript
// Service code (same in dev and prod)
this.http.post('/auth/login', credentials);

// Development:
// 1. Interceptor: /auth/login â†’ /api/auth/login
// 2. Proxy:       /api/auth/login â†’ http://localhost:3333/api/auth/login

// Production:
// 1. Interceptor: /auth/login â†’ /api/auth/login
// 2. Browser:     /api/auth/login â†’ https://yourdomain.com/api/auth/login
```

## ğŸ“– Related Documentation

- **[BaseUrlInterceptor Source](../../apps/web/src/app/core/http/interceptors/base-url.interceptor.ts)** - Implementation
- **[Proxy Configuration](../../apps/web/proxy.conf.js)** - Development proxy setup
- **[Swagger Documentation](http://127.0.0.1:3333/documentation)** - API reference
- **[CRUD Generator Quick Reference](../crud-generator/QUICK_REFERENCE.md)** - Auto-generated services

**Last Updated:** 2025-11-02
**Maintained By:** AegisX Platform Team
**Version:** 1.0.0
