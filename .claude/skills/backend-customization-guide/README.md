# Backend Customization Guide

> User-friendly documentation for customizing generated backend code

## Overview

This guide helps you customize the backend code generated by the AegisX CRUD generator. After generating basic CRUD operations, you'll often need to add business logic, custom endpoints, complex validations, and specialized queries.

## Quick Start

### Where to Add Code

Generated backend follows a layered architecture:

```
apps/api/src/layers/[layer]/[feature]/
├── [feature].controller.ts    ← Add HTTP handlers
├── [feature].service.ts        ← Add business logic (START HERE!)
├── [feature].repository.ts     ← Add database queries
├── [feature].routes.ts         ← Add route definitions
├── [feature].schemas.ts        ← Add TypeBox schemas
└── [feature].types.ts          ← Add type definitions
```

**Most customizations start in the Service Layer!**

## Common Customizations

### 1. Add Business Validation

**When:** You need to validate business rules beyond basic TypeBox schema validation

**Where:** Service layer (`[feature].service.ts`)

**How:** Override validation hooks

```typescript
// In [feature].service.ts
protected async validateCreate(data: CreateProduct): Promise<void> {
  // Check unique constraint
  const existing = await this.repository.findBySku(data.sku);
  if (existing) {
    throw new AppError('Product SKU already exists', 409, 'SKU_EXISTS');
  }

  // Check business rule
  if (data.price < 0) {
    throw new AppError('Price cannot be negative', 400, 'INVALID_PRICE');
  }
}

protected async validateUpdate(
  id: string | number,
  data: UpdateProduct,
  existing: Product
): Promise<void> {
  // Check if SKU changed and is unique
  if (data.sku && data.sku !== existing.sku) {
    const duplicate = await this.repository.findBySku(data.sku);
    if (duplicate && duplicate.id !== existing.id) {
      throw new AppError('Product SKU already exists', 409, 'SKU_EXISTS');
    }
  }
}

protected async validateDelete(
  id: string | number,
  existing: Product
): Promise<void> {
  // Check if product is used in orders
  const hasOrders = await this.repository.hasOrders(id);
  if (hasOrders) {
    throw new AppError(
      'Cannot delete product with existing orders',
      422,
      'HAS_ORDERS'
    );
  }
}
```

### 2. Create Custom Endpoints

**When:** You need endpoints beyond CRUD (approve, publish, calculate, bulk operations)

**Steps:**

1. Add schema in `[feature].schemas.ts`:

```typescript
export const ApproveProductSchema = Type.Object({
  approver_notes: Type.Optional(Type.String({ maxLength: 500 })),
});
```

2. Add business logic in `[feature].service.ts`:

```typescript
async approve(id: string | number, userId: string): Promise<Product> {
  const product = await this.getById(id);
  if (!product) {
    throw new AppError('Product not found', 404, 'NOT_FOUND');
  }

  if (product.status === 'approved') {
    throw new AppError('Already approved', 400, 'ALREADY_APPROVED');
  }

  return this.update(id, { status: 'approved' }, userId);
}
```

3. Add handler in `[feature].controller.ts`:

```typescript
async approve(
  request: FastifyRequest<{ Params: { id: string } }>,
  reply: FastifyReply
) {
  try {
    const { id } = request.params;
    const userId = request.user?.id;

    const product = await this.service.approve(id, userId);

    return reply.success(product, 'Product approved successfully');
  } catch (error) {
    request.log.error({ error }, 'Error approving product');
    throw error;
  }
}
```

4. Register route in `[feature].routes.ts`:

```typescript
// IMPORTANT: Add custom routes BEFORE /:id route
fastify.post('/:id/approve', {
  schema: {
    tags: ['Products'],
    summary: 'Approve product',
    params: ProductIdParamSchema,
    body: ApproveProductSchema,
    response: {
      200: ProductResponseSchema,
      404: SchemaRefs.NotFound,
    },
  },
  preValidation: [fastify.authenticate, fastify.verifyPermission('products', 'update')],
  handler: controller.approve.bind(controller),
});
```

### 3. Add Complex Database Queries

**When:** You need joins, aggregations, or complex filtering

**Where:** Repository layer (`[feature].repository.ts`)

**How:** Add custom query methods

```typescript
// In [feature].repository.ts
export class ProductRepository extends BaseRepository<...> {
  /**
   * Find product with category and supplier info
   */
  async findWithRelations(id: number | string): Promise<any> {
    return this.knex('products')
      .select(
        'products.*',
        'categories.name as category_name',
        'suppliers.name as supplier_name'
      )
      .leftJoin('categories', 'products.category_id', 'categories.id')
      .leftJoin('suppliers', 'products.supplier_id', 'suppliers.id')
      .where('products.id', id)
      .first();
  }

  /**
   * Get products by category with stock count
   */
  async findByCategory(categoryId: number): Promise<any[]> {
    return this.knex('products')
      .select(
        'products.*',
        this.knex.raw('COALESCE(SUM(stock.quantity), 0) as total_stock')
      )
      .leftJoin('stock', 'products.id', 'stock.product_id')
      .where('products.category_id', categoryId)
      .groupBy('products.id');
  }

  /**
   * Get product statistics
   */
  async getStats(): Promise<any> {
    const stats = await this.knex('products')
      .select([
        this.knex.raw('COUNT(*) as total'),
        this.knex.raw('COUNT(*) FILTER (WHERE status = \'active\') as active'),
        this.knex.raw('AVG(price) as avg_price'),
        this.knex.raw('SUM(stock_quantity) as total_stock'),
      ])
      .first();

    return {
      total: parseInt(stats?.total || '0'),
      active: parseInt(stats?.active || '0'),
      avgPrice: parseFloat(stats?.avg_price || '0'),
      totalStock: parseInt(stats?.total_stock || '0'),
    };
  }
}
```

### 4. Implement Soft Delete

**When:** You want to mark records as deleted instead of removing them

**Steps:**

1. Add column to migration:

```typescript
table.timestamp('deleted_at').nullable();
```

2. Override delete in repository:

```typescript
async delete(id: string | number): Promise<boolean> {
  const updated = await this.knex(this.tableName)
    .where('id', id)
    .update({ deleted_at: new Date() });

  return updated > 0;
}

async restore(id: string | number): Promise<boolean> {
  const updated = await this.knex(this.tableName)
    .where('id', id)
    .update({ deleted_at: null });

  return updated > 0;
}
```

3. Filter deleted records:

```typescript
protected applyCustomFilters(
  query: Knex.QueryBuilder,
  filters: any
): void {
  super.applyCustomFilters(query, filters);

  // Exclude soft-deleted records by default
  if (!filters.includeDeleted) {
    query.whereNull(`${this.tableName}.deleted_at`);
  }
}
```

### 5. Add Audit Logging

**When:** You need to track who created/updated records

**Steps:**

1. Add columns to migration:

```typescript
table.uuid('created_by').references('id').inTable('users');
table.uuid('updated_by').references('id').inTable('users');
```

2. Enable in repository constructor:

```typescript
constructor(knex: Knex) {
  super(
    knex,
    'products',
    ['products.name', 'products.sku'],
    [], // UUID fields
    {
      hasCreatedAt: true,
      hasUpdatedAt: true,
      hasCreatedBy: true,  // Enable audit
      hasUpdatedBy: true,  // Enable audit
    }
  );
}
```

3. BaseRepository automatically handles these fields when you pass `userId`:

```typescript
// In controller
const product = await this.service.create(request.body, request.user?.id);
```

### 6. Custom Permissions

**When:** You need resource-level permissions (users can only edit their own records)

**Where:** Service layer validation

```typescript
protected async validateUpdate(
  id: string | number,
  data: UpdateProduct,
  existing: Product
): Promise<void> {
  const userId = this.getCurrentUserId(); // From context

  // Check ownership
  if (existing.created_by !== userId && !this.isAdmin(userId)) {
    throw new AppError(
      'You can only edit your own products',
      403,
      'FORBIDDEN'
    );
  }
}

private isAdmin(userId: string): boolean {
  // Check user role from context
  return this.userRole === 'admin';
}
```

## Best Practices

### DO ✅

- **Start with Service Layer** - Put business logic in service, not controller or routes
- **Use TypeBox Schemas** - Always validate request/response with schemas
- **Throw AppError** - Use structured errors with status codes and error codes
- **Log Important Operations** - Use `request.log.info/error` for tracking
- **Bind Controller Methods** - Always use `.bind(controller)` in routes
- **Use Transactions** - Wrap multi-step operations in transactions

### DON'T ❌

- **Don't Modify Base Classes** - Extend and customize, don't change the base structure
- **Don't Skip Validation** - Always use TypeBox schemas for request validation
- **Don't Put Business Logic in Routes** - Keep routes thin, logic in service
- **Don't Access Database in Controller** - Always go through service layer
- **Don't Ignore Errors** - Handle null/undefined cases properly
- **Don't Hardcode Values** - Use constants and configuration

## Real-World Examples

### Example 1: Department Hierarchy

See: `apps/api/src/layers/platform/departments/`

**Customizations:**

- Validation for circular hierarchy prevention
- Custom endpoint for hierarchical tree structure
- Custom query for building nested hierarchy
- Validation for checking child departments before delete

### Example 2: User Profile with Password Management

**Customizations:**

- Custom validation for password strength
- Custom endpoint for password change
- Hashing password before save
- Checking old password before update

### Example 3: Product Inventory

**Customizations:**

- Stock level validation
- Custom query for low stock alerts
- Bulk update for price changes
- Custom statistics endpoint

## Troubleshooting

### Issue: Route not found (404)

**Cause:** Custom route registered after parameterized route

**Solution:** Place custom routes BEFORE `/:id` routes in `routes.ts`

```typescript
// ✅ Correct order
fastify.get('/stats', ...);      // Custom route first
fastify.get('/dropdown', ...);   // Custom route first
fastify.get('/:id', ...);        // Parameterized route last
```

### Issue: Validation error on create

**Cause:** Missing required fields or wrong data types

**Solution:** Check TypeBox schema matches request body

```typescript
// Check schema in [feature].schemas.ts
export const CreateProductSchema = Type.Object({
  name: Type.String({ minLength: 1 }), // Required
  price: Type.Number({ minimum: 0 }), // Required
  description: Type.Optional(Type.String()), // Optional
});
```

### Issue: "This context" error in controller

**Cause:** Forgot to bind controller method

**Solution:** Always use `.bind(controller)`

```typescript
// ❌ Wrong
handler: controller.create,

// ✅ Correct
handler: controller.create.bind(controller),
```

### Issue: Transaction timeout

**Cause:** Long-running operation or deadlock

**Solution:** Keep transactions short and specific

```typescript
// ✅ Good - short transaction
return this.withTransaction(async (trx) => {
  const created = await trx('products').insert(data).returning('*');
  await trx('stock').insert({ product_id: created[0].id, quantity: 0 });
  return created[0];
});

// ❌ Bad - too much in transaction
return this.withTransaction(async (trx) => {
  // Many operations, external API calls, etc.
});
```

## Getting Help

- Read [Backend Architecture](../../../docs/architecture/backend-architecture.md)
- Check [API Response Standard](../../../docs/reference/api/api-response-standard.md)
- See [TypeBox Schema Standard](../../../docs/reference/api/typebox-schema-standard.md)
- Ask Claude: "How do I customize [specific feature] in backend?"

## Next Steps

After customizing your backend:

1. **Test Endpoints** - Use `api-endpoint-tester` skill or curl
2. **Update Documentation** - Use `api-contract-generator` skill
3. **Verify Contract** - Use `api-contract-validator` skill
4. **Integrate Frontend** - Use `frontend-integration-guide` skill

---

**Pro Tip:** Study the `departments` module at `apps/api/src/layers/platform/departments/` for a complete example of backend customization with hierarchy management, validation, and custom endpoints.
