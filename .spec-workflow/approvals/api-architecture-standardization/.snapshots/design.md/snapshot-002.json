{
  "id": "snapshot_1765700590750_7q64v1b7j",
  "approvalId": "approval_1765700561567_2i12x4q43",
  "approvalTitle": "Design Document - API Architecture Standardization",
  "version": 2,
  "timestamp": "2025-12-14T08:23:10.749Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe API Architecture Standardization feature will establish a layer-based architecture (Core/Platform/Domains) for the Fastify API, replacing the current inconsistent structure. This design follows a spec-driven approach: first creating comprehensive specifications, then updating the CRUD generator, and finally migrating existing code systematically with zero downtime.\n\n**Key Design Principles:**\n- **Clarity through Layers**: Three distinct layers with clear boundaries\n- **Convention over Configuration**: Standard patterns reduce decision-making\n- **Backwards Compatibility**: Old routes continue working during migration\n- **Zero Downtime**: Gradual rollout with feature flags and route aliasing\n- **CRUD Generator Alignment**: Generator creates code following new standards automatically\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n*Note: No steering documents exist yet. This design follows general best practices:*\n\n- **TypeBox Schemas**: All routes use TypeBox for type-safe validation (existing standard)\n- **Repository-Service-Controller Pattern**: Maintain existing pattern across all layers\n- **Fastify Plugins**: Use `fastify-plugin` wrapper appropriately based on plugin purpose\n- **Dependency Injection**: Manual dependency injection via constructor parameters (existing approach)\n- **Error Handling**: Leverage existing global error handlers and response handlers\n- **WebSocket Support**: Existing WebSocket plugin remains available to all layers\n\n### Project Structure (structure.md)\n\n*Note: This design will CREATE the new structure standard:*\n\n```\napps/api/src/\n├── layers/                       # NEW: Layer-based organization\n│   ├── core/                     # Infrastructure layer\n│   ├── platform/                 # Shared services layer\n│   └── domains/                  # Business domains layer\n├── bootstrap/                    # MODIFY: Plugin loader\n├── config/                       # ADD: Route aliases, feature flags\n├── plugins/                      # KEEP: Global plugins (unchanged)\n└── shared/                       # KEEP: Shared utilities (unchanged)\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**1. Plugin Loader Infrastructure (`apps/api/src/bootstrap/plugin.loader.ts`)**\n- **Current**: Registers plugins in groups (infrastructure, database, authentication, core-infrastructure, business-features)\n- **Reuse**: Group-based loading pattern, error handling, timing metrics\n- **Extend**: Add layer-based groups, feature flag support, route aliasing\n\n**2. Auth Plugin Pattern (`apps/api/src/core/auth/auth.plugin.ts`)**\n- **Current**: Uses `fp()` wrapper, decorates fastify instance, declares dependencies\n- **Reuse**: This is the **correct pattern for infrastructure plugins** - will serve as template\n- **Usage**: Template for all Core layer plugins\n\n**3. Users Plugin Pattern (`apps/api/src/core/users/users.plugin.ts`)**\n- **Current**: Uses `fp()` wrapper, Repository→Service→Controller chain, decorates fastify\n- **Issues**: Should NOT use `fp()` wrapper (it's a leaf module, not infrastructure)\n- **Refactor**: Remove `fp()` wrapper, move to Platform layer\n\n**4. Response Handler Plugin (`apps/api/src/plugins/response-handler.plugin.ts`)**\n- **Current**: Provides standardized API responses (success(), error(), etc.)\n- **Reuse**: All layers will continue using this for consistent responses\n- **No changes needed**\n\n**5. Global Error Handlers**\n- **Current**: Centralized error handling with proper HTTP status codes\n- **Reuse**: All layers continue using existing error handling\n- **No changes needed**\n\n**6. TypeBox Schemas Registry (`apps/api/src/plugins/schemas.plugin.ts`)**\n- **Current**: Registers module schemas for validation\n- **Reuse**: All layers continue registering schemas\n- **No changes needed**\n\n### Integration Points\n\n**1. Plugin Loader (`apps/api/src/bootstrap/plugin.loader.ts`)**\n- **Integration**: Replace `createCorePluginGroup()` and `createFeaturePluginGroup()` with layer-based groups\n- **New Functions**: `createCoreLayerGroup()`, `createPlatformLayerGroup()`, `createDomainsLayerGroup()`\n- **Feature Flags**: Add conditional registration based on `ENABLE_NEW_ROUTES`, `ENABLE_OLD_ROUTES`\n\n**2. Route Aliasing Plugin (NEW: `apps/api/src/config/route-aliases.ts`)**\n- **Integration**: Register early in plugin loading sequence (after logging, before routes)\n- **Purpose**: Redirect old routes to new routes during migration\n- **Implementation**: Use `fastify.all()` with HTTP 307 redirects\n\n**3. Feature Flags (`apps/api/src/config/default.ts`)**\n- **Integration**: Extend existing config system\n- **New Flags**: `features.enableNewRoutes`, `features.enableOldRoutes`\n- **Usage**: Control which route sets are active\n\n**4. CRUD Generator (`libs/aegisx-cli/templates/`)**\n- **Integration**: Update all templates to generate layer-based structure\n- **Files to Modify**: `backend-route.ejs`, `backend-controller.ejs`, `backend-service.ejs`, etc.\n- **New Logic**: Determine layer based on domain/table type\n\n**5. Database Schema (No changes)**\n- **Integration**: No database schema changes required - pure code reorganization\n- **Existing Tables**: Remain unchanged\n- **Migrations**: None needed for this feature\n\n## Architecture\n\nThe architecture introduces three distinct layers with clear separation of concerns and dependency rules:\n\n```\n┌─────────────────────────────────────────────────────┐\n│                   API Gateway                        │\n│              (apps/api/src/server.ts)                │\n└──────────────────┬──────────────────────────────────┘\n                   │\n          ┌────────▼────────┐\n          │  Route Aliasing │  (During Migration)\n          │  /api → /api/v1 │\n          └────────┬────────┘\n                   │\n    ┌──────────────┴──────────────┐\n    │                             │\n    ▼                             ▼\n┌───────────┐               ┌───────────┐\n│ Old Routes│               │New Routes │\n│  (Phase   │               │ (Layer-   │\n│Migration) │               │  based)   │\n└───────────┘               └─────┬─────┘\n                                  │\n                    ┌─────────────┼─────────────┐\n                    │             │             │\n              ┌─────▼─────┐ ┌────▼────┐ ┌──────▼──────┐\n              │   Core    │ │Platform │ │  Domains    │\n              │   Layer   │ │  Layer  │ │   Layer     │\n              └───────────┘ └────┬────┘ └──────┬──────┘\n                    │             │             │\n                    └─────────────┴─────────────┘\n                                  │\n                         ┌────────▼────────┐\n                         │  Shared Services│\n                         │  (Database,     │\n                         │   WebSocket)    │\n                         └─────────────────┘\n```\n\n### Layer Dependency Rules\n\n```\nCore Layer\n  ↓ depends on: nothing (pure infrastructure)\n  ↓ used by: Platform, Domains\n\nPlatform Layer\n  ↓ depends on: Core only\n  ↓ used by: Domains\n\nDomains Layer\n  ↓ depends on: Core + Platform\n  ↓ used by: API consumers\n  ↓ isolation: Domain NEVER depends on another Domain\n```\n\n### Modular Design Principles\n\n1. **Single File Responsibility**: Each file handles one specific concern\n   - Plugin file: Registration and dependency declaration only\n   - Routes file: Route definitions only\n   - Controller file: Request/response handling only\n   - Service file: Business logic only\n   - Repository file: Database access only\n\n2. **Component Isolation**: Small, focused components\n   - Maximum ~300 lines per file (excluding generated code)\n   - Clear interfaces between components\n   - No circular dependencies\n\n3. **Service Layer Separation**:\n   - Repository Layer: Database queries (SELECT, INSERT, UPDATE, DELETE)\n   - Service Layer: Business logic, validation, transactions\n   - Controller Layer: HTTP request/response, serialization\n   - Plugin Layer: Registration, wiring, dependency management\n\n4. **Utility Modularity**:\n   - Shared utilities remain in `apps/api/src/shared/`\n   - Layer-specific utilities live within their layer\n   - No utilities duplicated across layers\n\n### Directory Structure Detail\n\n```\napps/api/src/\n├── layers/\n│   ├── core/                           # Layer 1: Core Infrastructure\n│   │   ├── auth/                       # Authentication primitives\n│   │   │   ├── auth.plugin.ts          # ✅ Uses fp() - decorates fastify\n│   │   │   ├── auth.routes.ts\n│   │   │   ├── auth.controller.ts\n│   │   │   ├── auth.service.ts\n│   │   │   ├── auth.schemas.ts\n│   │   │   └── strategies/\n│   │   ├── security/                   # API keys, rate limiting\n│   │   │   ├── api-keys/\n│   │   │   └── rate-limiting/\n│   │   ├── monitoring/                 # Logging, metrics, health\n│   │   │   ├── monitoring.plugin.ts    # ✅ Uses fp() - decorates fastify\n│   │   │   ├── services/\n│   │   │   └── plugins/\n│   │   └── audit/                      # Audit logs, compliance\n│   │       ├── audit.plugin.ts         # ✅ Uses fp() - decorates fastify\n│   │       ├── file-audit/\n│   │       └── login-attempts/\n│   │\n│   ├── platform/                       # Layer 2: Shared Services\n│   │   ├── users/                      # User management\n│   │   │   ├── users.plugin.ts         # ❌ Remove fp() - leaf module\n│   │   │   ├── users.routes.ts\n│   │   │   ├── users.controller.ts\n│   │   │   ├── users.service.ts\n│   │   │   ├── users.repository.ts\n│   │   │   └── users.schemas.ts\n│   │   ├── rbac/                       # Authorization\n│   │   │   ├── rbac.plugin.ts          # ❌ Remove fp() - leaf module\n│   │   │   └── ...\n│   │   ├── departments/                # Department management\n│   │   ├── settings/                   # System settings\n│   │   ├── navigation/                 # Menu navigation\n│   │   ├── files/                      # File upload/download\n│   │   ├── attachments/                # Attachment management\n│   │   ├── pdf-export/                 # PDF generation\n│   │   └── import/                     # Excel/CSV import\n│   │       ├── import.plugin.ts        # ✅ Uses fp() - aggregator\n│   │       ├── base/\n│   │       └── discovery/\n│   │\n│   └── domains/                        # Layer 3: Business Domains\n│       ├── inventory/                  # Inventory management\n│       │   ├── inventory.plugin.ts     # ✅ Uses fp() - domain aggregator\n│       │   ├── master-data/\n│       │   │   ├── drugs/\n│       │   │   │   ├── drugs.plugin.ts # ❌ No fp() - leaf module\n│       │   │   │   └── ...\n│       │   │   └── ...\n│       │   ├── operations/\n│       │   ├── procurement/\n│       │   └── budget/\n│       └── admin/                      # Admin features\n│           ├── admin.plugin.ts         # ✅ Uses fp() - domain aggregator\n│           └── system-init/\n│\n├── config/\n│   ├── default.ts                      # ADD: Feature flags\n│   └── route-aliases.ts                # NEW: Route aliasing plugin\n│\n├── bootstrap/\n│   └── plugin.loader.ts                # MODIFY: Layer-based loading\n│\n├── plugins/                            # UNCHANGED: Global plugins\n└── shared/                             # UNCHANGED: Shared utilities\n```\n\n## Components and Interfaces\n\n### Component 1: Layer-Based Plugin Loader\n\n**Purpose:** Manage plugin registration in layer-based groups with feature flag support\n\n**File:** `apps/api/src/bootstrap/plugin.loader.ts`\n\n**Interfaces:**\n\n```typescript\n// New layer-based group creators\nexport function createCoreLayerGroup(): PluginGroup;\nexport function createPlatformLayerGroup(): PluginGroup;\nexport function createDomainsLayerGroup(): PluginGroup;\n\n// Enhanced plugin registration with feature flags\nexport async function loadAllPlugins(\n  fastify: FastifyInstance,\n  appConfig: AppConfig,\n  securityConfig: SecurityConfig,\n  databaseConfig: DatabaseConfig,\n  quiet?: boolean\n): Promise<void>;\n```\n\n**Dependencies:**\n- Fastify instance\n- Config objects (appConfig, securityConfig, databaseConfig)\n- All plugin modules\n\n**Reuses:**\n- Existing `PluginGroup` interface\n- Existing `loadPluginGroup()` function\n- Existing error handling and timing logic\n\n**Changes:**\n- Replace `createCorePluginGroup()` with `createCoreLayerGroup()`\n- Replace `createFeaturePluginGroup()` with `createPlatformLayerGroup()` and `createDomainsLayerGroup()`\n- Add conditional loading based on feature flags\n\n### Component 2: Route Aliasing Plugin\n\n**Purpose:** Provide backwards compatibility by redirecting old routes to new layer-based routes\n\n**File:** `apps/api/src/config/route-aliases.ts` (NEW)\n\n**Interfaces:**\n\n```typescript\nexport interface RouteAliasConfig {\n  enableAliasing: boolean;\n  aliasMap: Record<string, string>; // old -> new\n}\n\nexport const routeAliasPlugin: FastifyPluginAsync<RouteAliasConfig>;\n```\n\n**Implementation:**\n\n```typescript\nimport fp from 'fastify-plugin';\nimport { FastifyInstance, FastifyPluginOptions } from 'fastify';\n\nexport const routeAliasPlugin = fp(\n  async function (fastify: FastifyInstance, opts: FastifyPluginOptions) {\n    const config = fastify.config;\n\n    // Skip if feature disabled\n    if (!config.features.enableNewRoutes) {\n      return;\n    }\n\n    const aliasMap: Record<string, string> = {\n      '/api/auth': '/api/v1/core/auth',\n      '/api/users': '/api/v1/platform/users',\n      '/api/rbac': '/api/v1/platform/rbac',\n      '/api/departments': '/api/v1/platform/departments',\n      '/api/settings': '/api/v1/platform/settings',\n      '/api/inventory': '/api/v1/domains/inventory',\n      '/api/admin': '/api/v1/domains/admin',\n    };\n\n    // Register redirect handlers\n    for (const [oldPath, newPath] of Object.entries(aliasMap)) {\n      fastify.all(`${oldPath}/*`, async (request, reply) => {\n        const targetPath = request.url.replace(oldPath, newPath);\n\n        // Log usage for metrics\n        if (fastify.monitoring) {\n          fastify.monitoring.recordEvent('route_alias_used', {\n            old: request.url,\n            new: targetPath,\n            method: request.method,\n          });\n        }\n\n        // HTTP 307: Temporary redirect (preserves method & body)\n        return reply.redirect(307, targetPath);\n      });\n    }\n  },\n  {\n    name: 'route-alias-plugin',\n    dependencies: ['logging-plugin'], // Log before aliasing\n  }\n);\n```\n\n**Dependencies:**\n- Logging plugin (optional: for metrics)\n- Config plugin (for feature flags)\n\n**Reuses:**\n- Existing fastify-plugin pattern\n- Existing monitoring service (if available)\n\n### Component 3: Feature Flags Configuration\n\n**Purpose:** Control which route sets are active during migration\n\n**File:** `apps/api/src/config/default.ts` (EXTEND)\n\n**Interfaces:**\n\n```typescript\nexport interface AppConfig {\n  // ... existing config ...\n  features: {\n    enableNewRoutes: boolean;  // NEW\n    enableOldRoutes: boolean;  // NEW\n  };\n}\n```\n\n**Implementation:**\n\n```typescript\nexport default {\n  // ... existing config ...\n  features: {\n    enableNewRoutes: process.env.ENABLE_NEW_ROUTES === 'true',\n    enableOldRoutes: process.env.ENABLE_OLD_ROUTES !== 'false', // Default true\n  },\n};\n```\n\n**Dependencies:** None (pure configuration)\n\n**Reuses:** Existing config structure and loading mechanism\n\n### Component 4: Infrastructure Plugin Template\n\n**Purpose:** Standard template for Core layer plugins that decorate fastify instance\n\n**Pattern:** Use `fastify-plugin` (fp) wrapper\n\n**Example:** `apps/api/src/layers/core/monitoring/monitoring.plugin.ts`\n\n```typescript\nimport fp from 'fastify-plugin';\nimport { FastifyInstance, FastifyPluginOptions } from 'fastify';\nimport { MonitoringService } from './services/monitoring.service';\n\nexport default fp(\n  async function monitoringPlugin(\n    fastify: FastifyInstance,\n    opts: FastifyPluginOptions\n  ) {\n    // Initialize service\n    const service = new MonitoringService(fastify.config);\n    await service.initialize();\n\n    // Decorate fastify instance\n    fastify.decorate('monitoring', service);\n\n    // Register lifecycle hooks\n    fastify.addHook('onRequest', async (request) => {\n      request.startTime = Date.now();\n    });\n\n    fastify.addHook('onResponse', async (request, reply) => {\n      const duration = Date.now() - request.startTime;\n      service.recordMetric('http_request_duration_ms', duration);\n    });\n\n    // Cleanup on close\n    fastify.addHook('onClose', async () => {\n      await service.close();\n    });\n  },\n  {\n    name: 'monitoring-plugin',\n    dependencies: ['config-plugin'],\n  }\n);\n\n// TypeScript declarations\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    monitoring: MonitoringService;\n  }\n}\n```\n\n**When to use:**\n- Plugin decorates fastify instance\n- Plugin registers global hooks\n- Plugin manages lifecycle (initialize/close)\n- Plugin has explicit dependencies\n\n### Component 5: Leaf Module Plugin Template\n\n**Purpose:** Standard template for Platform/Domain leaf modules (routes + controllers)\n\n**Pattern:** Plain async function (NO fp wrapper)\n\n**Example:** `apps/api/src/layers/platform/users/users.plugin.ts`\n\n```typescript\nimport { FastifyInstance, FastifyPluginOptions } from 'fastify';\nimport { UsersRepository } from './users.repository';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { usersRoutes } from './users.routes';\nimport { usersSchemas } from './users.schemas';\n\nexport default async function usersPlugin(\n  fastify: FastifyInstance,\n  opts: FastifyPluginOptions\n) {\n  // Register schemas\n  if ((fastify as any).schemaRegistry) {\n    (fastify as any).schemaRegistry.registerModuleSchemas(\n      'users',\n      usersSchemas\n    );\n  }\n\n  // Initialize dependency chain\n  const repository = new UsersRepository(fastify.knex);\n  const service = new UsersService(repository);\n  const controller = new UsersController(service, fastify.eventService);\n\n  // Register routes\n  await fastify.register(usersRoutes, {\n    controller,\n    prefix: opts.prefix || '/users',\n  });\n}\n```\n\n**When to use:**\n- Plugin only registers routes/controllers\n- Plugin does NOT decorate fastify instance\n- Plugin is a terminal/leaf module\n- Plugin respects encapsulation (isolated from siblings)\n\n### Component 6: Domain Aggregator Plugin Template\n\n**Purpose:** Standard template for domain-level aggregators that group related modules\n\n**Pattern:** Use `fastify-plugin` (fp) wrapper\n\n**Example:** `apps/api/src/layers/domains/inventory/inventory.plugin.ts`\n\n```typescript\nimport fp from 'fastify-plugin';\nimport { FastifyInstance, FastifyPluginOptions } from 'fastify';\nimport masterDataPlugin from './master-data/master-data.plugin';\nimport operationsPlugin from './operations/operations.plugin';\nimport procurementPlugin from './procurement/procurement.plugin';\nimport budgetPlugin from './budget/budget.plugin';\n\nexport default fp(\n  async function inventoryPlugin(\n    fastify: FastifyInstance,\n    opts: FastifyPluginOptions\n  ) {\n    // Register all sub-domains with sub-prefixes\n    await fastify.register(masterDataPlugin, {\n      prefix: '/master-data',\n    });\n\n    await fastify.register(operationsPlugin, {\n      prefix: '/operations',\n    });\n\n    await fastify.register(procurementPlugin, {\n      prefix: '/procurement',\n    });\n\n    await fastify.register(budgetPlugin, {\n      prefix: '/budget',\n    });\n  },\n  {\n    name: 'inventory-plugin',\n    // No dependencies - children manage their own\n  }\n);\n```\n\n**When to use:**\n- Plugin aggregates multiple child plugins\n- Plugin provides namespace isolation\n- Plugin coordinates related functionality\n- Child plugins need access to parent context\n\n### Component 7: CRUD Generator Updates\n\n**Purpose:** Generate code following layer-based architecture\n\n**Files to Modify:**\n- `libs/aegisx-cli/templates/backend/plugin.ejs`\n- `libs/aegisx-cli/templates/backend/routes.ejs`\n- `libs/aegisx-cli/templates/backend/controller.ejs`\n- `libs/aegisx-cli/templates/backend/service.ejs`\n- `libs/aegisx-cli/templates/backend/repository.ejs`\n- `libs/aegisx-cli/src/generators/backend.generator.ts`\n\n**Key Changes:**\n\n1. **Directory Structure**:\n```javascript\n// OLD\nconst outputDir = `apps/api/src/modules/${domain}/${type}/${tableName}`;\n\n// NEW\nconst layer = determineLayer(domain, type);\nconst outputDir = `apps/api/src/layers/${layer}/${domain}/${type}/${tableName}`;\n\nfunction determineLayer(domain: string, type: string): 'core' | 'platform' | 'domains' {\n  // Core: Infrastructure (auth, monitoring, audit)\n  if (['auth', 'monitoring', 'audit', 'security'].includes(domain)) {\n    return 'core';\n  }\n\n  // Platform: Shared services (users, files, settings)\n  if (['users', 'rbac', 'files', 'settings', 'departments'].includes(domain)) {\n    return 'platform';\n  }\n\n  // Domains: Everything else (inventory, admin, hr, finance)\n  return 'domains';\n}\n```\n\n2. **Plugin Template**:\n```ejs\n<%# Determine if should use fp() wrapper %>\n<% const useFp = layer === 'core' || isAggregator; %>\n\n<% if (useFp) { %>\nimport fp from 'fastify-plugin';\n\nexport default fp(\n  async function <%= pluginName %>Plugin(fastify, opts) {\n    // ... implementation ...\n  },\n  {\n    name: '<%= pluginName %>-plugin',\n    dependencies: <%= JSON.stringify(dependencies) %>,\n  }\n);\n<% } else { %>\nexport default async function <%= pluginName %>Plugin(fastify, opts) {\n  // ... implementation ...\n}\n<% } %>\n```\n\n3. **URL Routing**:\n```ejs\n// OLD\nprefix: opts.prefix || '/<%= tableName %>',\n\n// NEW\nprefix: opts.prefix || '/api/v1/<%= layer %>/<%= domain %>/<%= tableName %>',\n```\n\n**Dependencies:**\n- Existing template system\n- Domain classification logic\n\n**Reuses:**\n- Existing EJS templates\n- Existing generator infrastructure\n\n## Data Models\n\n### Model 1: Plugin Registration Metadata\n\n```typescript\ninterface PluginGroup {\n  name: string;                    // Group identifier\n  description: string;             // Human-readable description\n  layer?: 'core' | 'platform' | 'domains'; // NEW: Layer classification\n  plugins: PluginRegistration[];\n}\n\ninterface PluginRegistration {\n  name: string;                    // Plugin name\n  plugin: any;                     // Plugin function\n  options?: any;                   // Plugin options\n  required?: boolean;              // Is plugin required?\n  layer?: 'core' | 'platform' | 'domains'; // NEW: Layer classification\n  urlPattern?: string;             // NEW: URL pattern (e.g., /api/v1/core/auth)\n}\n```\n\n### Model 2: Route Alias Mapping\n\n```typescript\ninterface RouteAlias {\n  oldPath: string;                 // Old route pattern\n  newPath: string;                 // New route pattern\n  preserveMethod: boolean;         // Preserve HTTP method (always true)\n  preserveBody: boolean;           // Preserve request body (always true)\n  statusCode: 307;                 // HTTP 307 Temporary Redirect\n}\n\ninterface RouteAliasMetrics {\n  route: string;                   // Old route that was aliased\n  targetRoute: string;             // New route redirected to\n  hitCount: number;                // Number of times aliased\n  uniqueClients: number;           // Distinct client IDs\n  firstSeen: Date;                 // First usage timestamp\n  lastSeen: Date;                  // Last usage timestamp\n}\n```\n\n### Model 3: Feature Flags\n\n```typescript\ninterface FeatureFlags {\n  enableNewRoutes: boolean;        // Enable /api/v1/{layer}/{resource} routes\n  enableOldRoutes: boolean;        // Enable legacy routes (with aliasing)\n}\n\n// Environment variables\nprocess.env.ENABLE_NEW_ROUTES      // \"true\" | \"false\"\nprocess.env.ENABLE_OLD_ROUTES      // \"true\" | \"false\" (default: \"true\")\n```\n\n### Model 4: Layer Classification Rules\n\n```typescript\ntype Layer = 'core' | 'platform' | 'domains';\n\ninterface ModuleClassification {\n  moduleName: string;\n  currentPath: string;             // Current location\n  targetLayer: Layer;              // Target layer\n  targetPath: string;              // Target location\n  reason: string;                  // Reason for classification\n  useFpWrapper: boolean;           // Should use fp() wrapper?\n  dependencies: string[];          // Plugin dependencies\n}\n\n// Classification examples\nconst classifications: ModuleClassification[] = [\n  {\n    moduleName: 'auth',\n    currentPath: 'apps/api/src/core/auth',\n    targetLayer: 'core',\n    targetPath: 'apps/api/src/layers/core/auth',\n    reason: 'Infrastructure - authentication primitives',\n    useFpWrapper: true,\n    dependencies: ['knex-plugin', 'jwt-plugin'],\n  },\n  {\n    moduleName: 'users',\n    currentPath: 'apps/api/src/core/users',\n    targetLayer: 'platform',\n    targetPath: 'apps/api/src/layers/platform/users',\n    reason: 'Shared service - used by multiple domains',\n    useFpWrapper: false,\n    dependencies: ['knex-plugin'],\n  },\n  {\n    moduleName: 'inventory',\n    currentPath: 'apps/api/src/modules/inventory',\n    targetLayer: 'domains',\n    targetPath: 'apps/api/src/layers/domains/inventory',\n    reason: 'Business logic - inventory domain',\n    useFpWrapper: true, // Aggregator\n    dependencies: [],\n  },\n];\n```\n\n## Error Handling\n\n### Error Scenario 1: Plugin Registration Failure\n\n**Description:** Plugin fails to load due to missing dependency or initialization error\n\n**Handling:**\n- If `required: true`: Throw error, prevent server startup, log detailed error message\n- If `required: false`: Log warning, continue with other plugins, track failure in metrics\n\n**User Impact:**\n- Development: Clear error message with plugin name, dependency chain, and fix suggestions\n- Production: Server fails to start if critical plugin fails (prevents broken state)\n\n**Example:**\n```typescript\ntry {\n  await fastify.register(pluginReg.plugin, pluginReg.options);\n} catch (error) {\n  const errorMsg = error instanceof Error ? error.message : String(error);\n\n  if (pluginReg.required) {\n    console.error(`❌ ${pluginReg.name} FAILED: ${errorMsg}`);\n    throw new Error(\n      `Required plugin ${pluginReg.name} failed to load: ${errorMsg}\\n` +\n      `Dependencies: ${JSON.stringify(pluginReg.dependencies || [])}\\n` +\n      `Hint: Check if all dependencies are registered before this plugin.`\n    );\n  } else {\n    console.warn(`⚠️ ${pluginReg.name} OPTIONAL FAILED: ${errorMsg}`);\n    // Continue without this plugin\n  }\n}\n```\n\n### Error Scenario 2: Route Aliasing Redirect Failure\n\n**Description:** Route alias redirect fails (e.g., new route doesn't exist)\n\n**Handling:**\n- Log error with old route, target route, and error details\n- Return HTTP 500 with helpful error message\n- Alert monitoring system\n\n**User Impact:**\n- API consumers receive error response with migration guide link\n- DevOps team receives alert about broken alias\n\n**Example:**\n```typescript\nfastify.all(`${oldPath}/*`, async (request, reply) => {\n  try {\n    const targetPath = request.url.replace(oldPath, newPath);\n    return reply.redirect(307, targetPath);\n  } catch (error) {\n    fastify.log.error({\n      error,\n      oldPath: request.url,\n      targetPath,\n      message: 'Route alias redirect failed',\n    });\n\n    return reply.code(500).send({\n      error: 'Internal Server Error',\n      message: 'Route aliasing failed. Please use new API URL format.',\n      migration_guide: '/docs/api-migration-guide',\n      old_url: request.url,\n      new_url_pattern: '/api/v1/{layer}/{resource}',\n    });\n  }\n});\n```\n\n### Error Scenario 3: Feature Flag Configuration Error\n\n**Description:** Invalid feature flag configuration (e.g., both flags disabled)\n\n**Handling:**\n- Validate flags at server startup\n- Prevent invalid configurations (both disabled = no routes work)\n- Log warning if both enabled (migration mode)\n\n**User Impact:**\n- Server fails to start with clear error message\n- Configuration fix suggested in error output\n\n**Example:**\n```typescript\n// In server.ts startup validation\nfunction validateFeatureFlags(config: AppConfig): void {\n  const { enableNewRoutes, enableOldRoutes } = config.features;\n\n  // Invalid: Both disabled\n  if (!enableNewRoutes && !enableOldRoutes) {\n    throw new Error(\n      'Invalid configuration: Both ENABLE_NEW_ROUTES and ENABLE_OLD_ROUTES are false.\\n' +\n      'At least one must be enabled for API to function.\\n' +\n      'Recommended: Set ENABLE_NEW_ROUTES=true for migration mode.'\n    );\n  }\n\n  // Warning: Both enabled (migration mode)\n  if (enableNewRoutes && enableOldRoutes) {\n    console.warn(\n      '⚠️  Migration mode: Both old and new routes enabled.\\n' +\n      '   Old routes will redirect to new routes.\\n' +\n      '   Disable old routes after clients migrate: ENABLE_OLD_ROUTES=false'\n    );\n  }\n}\n```\n\n### Error Scenario 4: Module Categorization Ambiguity\n\n**Description:** Developer unsure which layer a new module belongs to\n\n**Handling:**\n- Provide decision tree in documentation\n- CLI helper command to suggest layer\n- Validation in CRUD generator with confirmation prompt\n\n**User Impact:**\n- Developer receives clear guidance\n- Prevents incorrect module placement\n\n**Example:**\n```bash\n# CLI helper\n$ pnpm run check-layer -- user-sessions\n\nAnalyzing: user-sessions\n\nQuestions:\n1. Does it provide infrastructure? (auth, logging, monitoring) → No\n2. Is it used by multiple domains? → Yes\n3. Is it business-specific to one domain? → No\n\nRecommendation: Platform Layer\nPath: apps/api/src/layers/platform/user-sessions\nReason: Shared service used by multiple domains\n\nUse fp() wrapper? No (leaf module)\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach:** Test individual components in isolation\n\n**Key Components to Test:**\n\n1. **Route Aliasing Plugin**:\n   - Test old route redirects to correct new route\n   - Test HTTP method preservation (GET, POST, PUT, DELETE)\n   - Test request body preservation\n   - Test query string preservation\n   - Test metrics logging\n\n2. **Plugin Loader**:\n   - Test layer-based group creation\n   - Test feature flag conditional loading\n   - Test error handling for required vs optional plugins\n   - Test plugin dependency resolution\n\n3. **Module Classification Logic** (CRUD Generator):\n   - Test layer determination for different domains\n   - Test fp() wrapper decision logic\n   - Test URL pattern generation\n\n**Test Files:**\n```\napps/api/src/config/__tests__/route-aliases.test.ts\napps/api/src/bootstrap/__tests__/plugin.loader.test.ts\nlibs/aegisx-cli/src/__tests__/layer-classification.test.ts\n```\n\n**Example Test:**\n```typescript\ndescribe('Route Aliasing Plugin', () => {\n  it('should redirect /api/users to /api/v1/platform/users with 307', async () => {\n    const app = await createTestApp({ enableNewRoutes: true });\n\n    const response = await app.inject({\n      method: 'GET',\n      url: '/api/users/123',\n    });\n\n    expect(response.statusCode).toBe(307);\n    expect(response.headers.location).toBe('/api/v1/platform/users/123');\n  });\n\n  it('should preserve POST body during redirect', async () => {\n    const app = await createTestApp({ enableNewRoutes: true });\n\n    const response = await app.inject({\n      method: 'POST',\n      url: '/api/users',\n      payload: { name: 'John' },\n    });\n\n    expect(response.statusCode).toBe(307);\n    // Note: HTTP 307 spec requires client to preserve body\n  });\n});\n```\n\n### Integration Testing\n\n**Approach:** Test layer interactions and plugin registration flow\n\n**Key Flows to Test:**\n\n1. **Full Server Startup with New Routes**:\n   - Start server with `ENABLE_NEW_ROUTES=true`\n   - Verify all layers load successfully\n   - Verify routes registered at correct paths\n   - Verify cross-layer dependencies work\n\n2. **Migration Mode (Both Routes Active)**:\n   - Start with both flags enabled\n   - Test old routes redirect correctly\n   - Test new routes work directly\n   - Verify metrics track alias usage\n\n3. **Gradual Migration**:\n   - Start with old routes only\n   - Enable new routes (migration mode)\n   - Disable old routes (cutover complete)\n   - Verify no downtime at each transition\n\n**Test Files:**\n```\napps/api/src/__tests__/integration/layer-architecture.test.ts\napps/api/src/__tests__/integration/migration-flow.test.ts\n```\n\n**Example Test:**\n```typescript\ndescribe('Layer Architecture Integration', () => {\n  it('should load all three layers in correct order', async () => {\n    const app = await createTestApp();\n\n    // Core layer loaded first\n    expect(app.authService).toBeDefined();\n    expect(app.monitoring).toBeDefined();\n\n    // Platform layer loaded second\n    expect(app.hasRoute('GET', '/api/v1/platform/users')).toBe(true);\n\n    // Domains layer loaded third\n    expect(app.hasRoute('GET', '/api/v1/domains/inventory/drugs')).toBe(true);\n  });\n\n  it('should enforce dependency rules between layers', () => {\n    // Platform can depend on Core\n    const platformService = new UsersService(/* core dependencies */);\n    expect(platformService).toBeDefined();\n\n    // Domain can depend on Platform + Core\n    const domainService = new InventoryService(\n      /* platform and core dependencies */\n    );\n    expect(domainService).toBeDefined();\n\n    // Domain should NOT depend on another Domain (enforced by architecture)\n  });\n});\n```\n\n### End-to-End Testing\n\n**Approach:** Test complete user journeys through API\n\n**User Scenarios to Test:**\n\n1. **API Consumer Using Old Routes**:\n   - Consumer calls `/api/users`\n   - Gets redirected to `/api/v1/platform/users`\n   - Receives same response format\n   - Deprecation headers present\n\n2. **API Consumer Using New Routes**:\n   - Consumer calls `/api/v1/platform/users`\n   - No redirection occurs\n   - Response format identical to old route\n   - Performance within SLA\n\n3. **CRUD Generator End-to-End**:\n   - Run generator for new table\n   - Verify files created in correct layer\n   - Verify routes work immediately\n   - Verify generated code passes linting\n\n**Test Files:**\n```\napps/api/src/__tests__/e2e/api-consumer-journey.test.ts\nlibs/aegisx-cli/__tests__/e2e/generator-full-flow.test.ts\n```\n\n**Example Test:**\n```typescript\ndescribe('API Consumer Migration Journey', () => {\n  it('should support gradual client migration', async () => {\n    const app = await createTestApp({\n      enableOldRoutes: true,\n      enableNewRoutes: true,\n    });\n\n    // Old client (using legacy routes)\n    const oldResponse = await app.inject({\n      method: 'GET',\n      url: '/api/users/123',\n    });\n    expect(oldResponse.statusCode).toBe(307); // Redirected\n    expect(oldResponse.headers['x-api-deprecated']).toBe('true');\n\n    // New client (using versioned routes)\n    const newResponse = await app.inject({\n      method: 'GET',\n      url: '/api/v1/platform/users/123',\n    });\n    expect(newResponse.statusCode).toBe(200); // Direct\n    expect(newResponse.headers['x-api-deprecated']).toBeUndefined();\n\n    // Responses should be identical\n    expect(oldResponse.json()).toEqual(newResponse.json());\n  });\n});\n```\n\n## Migration Architecture\n\n### Phase-by-Phase Architecture Changes\n\n**Phase 1: Specifications (Weeks 1-2)**\n- No code changes\n- Document creation only\n- Architecture diagrams in specs\n- Review and approval gates\n\n**Phase 2: CRUD Generator (Week 3)**\n- Modify templates to support layer structure\n- Add layer classification logic\n- Update CLI to accept layer parameter\n- Ensure backward compatibility (can still generate old format)\n\n**Phase 3: Setup & Route Aliasing (Week 4)**\n- Create `apps/api/src/layers/{core,platform,domains}/` directories\n- Implement route aliasing plugin\n- Add feature flags to config\n- Update plugin loader to support dual registration\n- Deploy with flags disabled (no behavior change)\n\n**Phase 4: Incremental Migration (Weeks 5-7)**\n- Copy modules to new locations (don't delete old yet)\n- Update plugin patterns (fp vs plain async)\n- Register both old and new routes\n- Test in staging environment\n- Canary deployment to production\n\n**Phase 5: Testing (Week 8)**\n- Comprehensive test suite execution\n- Performance benchmarking\n- Load testing\n- Security scanning\n\n**Phase 6: Cleanup (Weeks 9-10)**\n- Disable old routes\n- Delete old code\n- Remove route aliasing (after sunset period)\n- Archive migration artifacts\n\n### Rollback Architecture\n\nEach phase has specific rollback capability:\n\n**Phase 3-4 Rollback**: Disable `ENABLE_NEW_ROUTES` flag → instant revert\n**Phase 5 Rollback**: Deployment rollback via CI/CD → 5-minute recovery\n**Phase 6 Rollback**: Re-enable `ENABLE_OLD_ROUTES` flag → restore old routes\n\n### Performance Architecture\n\n**Aliasing Performance:**\n- Route matching: O(1) hash map lookup\n- Redirect overhead: <5ms (URL string replacement)\n- No database queries added\n- No serialization overhead\n\n**Plugin Loading Performance:**\n- Layer-based groups load sequentially (Core → Platform → Domains)\n- Within layer, plugins load in parallel where possible\n- Dependency resolution unchanged\n- Startup time target: <10% increase\n\n### Security Architecture\n\n**Route Aliasing Security:**\n- Redirects preserve authentication headers\n- CSRF tokens maintained through 307 redirect\n- Rate limiting applies before redirection\n- Audit logs capture both old and new URLs\n\n**Layer Isolation:**\n- Domains cannot access other Domains directly (architectural boundary)\n- Platform services accessed via dependency injection only\n- Core infrastructure available globally (by design)\n\n## Implementation Roadmap\n\n### Week 1-2: Specification Documents\n- Create 5 specification documents (this document + 4 others)\n- Team review and feedback incorporation\n- Stakeholder approval\n\n### Week 3: CRUD Generator Updates\n- Modify templates in `libs/aegisx-cli/templates/`\n- Add layer classification logic\n- Test generator with sample tables\n- Update generator documentation\n\n### Week 4: Setup & Route Aliasing\n- Create layer directory structure\n- Implement route aliasing plugin\n- Add feature flags\n- Update plugin loader\n- Deploy to production (flags disabled)\n\n### Week 5: Low-Risk Migration\n- Migrate `departments`, `settings`, `navigation`\n- Test dual routes\n- Monitor metrics\n- Canary deployment\n\n### Week 6: Medium-Risk Migration\n- Migrate `users`, `rbac`, `files`, `attachments`, `pdf-export`, `import`\n- Comprehensive testing\n- Gradual rollout\n\n### Week 7: High-Risk Migration\n- Migrate `auth`, `monitoring`, `audit`\n- Migrate `inventory`, `admin` domains\n- Full testing suite\n- Production deployment\n\n### Week 8: Testing\n- Unit + integration + E2E tests\n- Performance benchmarks\n- Load testing\n- Security audit\n\n### Week 9-10: Cleanup\n- Soft deprecation (headers)\n- Hard cutover (disable old routes)\n- Delete old code\n- Update documentation\n\nTotal: 10 weeks from spec to production-ready\n",
  "fileStats": {
    "size": 39986,
    "lines": 1209,
    "lastModified": "2025-12-14T08:22:32.754Z"
  },
  "comments": []
}
