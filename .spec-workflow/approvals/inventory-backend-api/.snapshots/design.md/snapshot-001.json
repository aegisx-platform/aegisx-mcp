{
  "id": "snapshot_1765718181699_yrttop8r3",
  "approvalId": "approval_1765718181644_luhprkw9s",
  "approvalTitle": "Inventory Backend API - Design Document",
  "version": 1,
  "timestamp": "2025-12-14T13:16:21.699Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document - Inventory Backend API\n\n## Overview\n\nThe Inventory Backend API implements a comprehensive drug inventory management system with real-time stock tracking, FIFO/FEFO lot management, and complete audit trails. The system is designed following domain-driven design principles, implementing the `inventory/operations` domain with three core entities and twelve RESTful endpoints.\n\n**Key Design Principles:**\n- **API-First Development**: Complete API specification before implementation\n- **Domain-Driven Design**: Operations domain with clear bounded contexts\n- **TypeBox Schema Validation**: Type-safe request/response contracts\n- **Repository Pattern**: Clean separation of data access from business logic\n- **Service Layer**: Centralized business logic and workflow orchestration\n- **Immutable Audit Trail**: Transaction log for regulatory compliance\n- **Database Functions**: Complex business logic (FIFO/FEFO) in PostgreSQL\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThis design follows AegisX platform standards:\n\n1. **Fastify Framework**: All endpoints use Fastify with TypeBox schema validation\n2. **Layered Architecture**: Repository → Service → Controller → Routes pattern\n3. **TypeScript Strict Mode**: Full type safety across all layers\n4. **BaseRepository Pattern**: Extends platform BaseRepository for CRUD operations\n5. **Authentication**: JWT-based authentication via `fastify.authenticate` hook\n6. **Authorization**: RBAC via `fastify.verifyPermission` hook\n7. **Error Handling**: Standardized AppError with error codes\n8. **Logging**: Structured logging with correlation IDs\n9. **WebSocket Events**: Real-time updates via EventService\n10. **Database**: PostgreSQL with Knex query builder\n\n### Project Structure (structure.md)\n\nImplementation follows project organization conventions:\n\n```\napps/api/src/layers/inventory/operations/\n├── inventory/\n│   ├── inventory.repository.ts\n│   ├── inventory.service.ts\n│   ├── inventory.controller.ts\n│   ├── inventory.routes.ts\n│   ├── inventory.schemas.ts\n│   ├── inventory.types.ts\n│   ├── index.ts\n│   └── __tests__/\n│       ├── inventory.repository.spec.ts\n│       ├── inventory.service.spec.ts\n│       └── inventory.controller.spec.ts\n├── drug-lots/\n│   ├── drug-lots.repository.ts\n│   ├── drug-lots.service.ts\n│   ├── drug-lots.controller.ts\n│   ├── drug-lots.routes.ts\n│   ├── drug-lots.schemas.ts\n│   ├── drug-lots.types.ts\n│   ├── index.ts\n│   └── __tests__/\n├── inventory-transactions/\n│   ├── inventory-transactions.repository.ts\n│   ├── inventory-transactions.service.ts\n│   ├── inventory-transactions.controller.ts\n│   ├── inventory-transactions.routes.ts\n│   ├── inventory-transactions.schemas.ts\n│   ├── inventory-transactions.types.ts\n│   ├── index.ts\n│   └── __tests__/\n├── inventory-adjustments/\n│   ├── inventory-adjustments.service.ts\n│   ├── inventory-adjustments.controller.ts\n│   ├── inventory-adjustments.routes.ts\n│   ├── inventory-adjustments.schemas.ts\n│   └── __tests__/\n├── inventory-transfers/\n│   ├── inventory-transfers.service.ts\n│   ├── inventory-transfers.controller.ts\n│   ├── inventory-transfers.routes.ts\n│   ├── inventory-transfers.schemas.ts\n│   └── __tests__/\n└── workflows/\n    ├── receipt-posting.workflow.ts\n    ├── fifo-dispensing.workflow.ts\n    ├── expiry-management.workflow.ts\n    └── __tests__/\n```\n\n**Database Schema**: `inventory` (separate schema from `public`)\n\n**Migration Path**: `apps/api/src/database/migrations-inventory/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **BaseRepository** (`shared/repositories/base.repository.ts`)\n   - **Usage**: All repositories extend BaseRepository for standard CRUD operations\n   - **Features**: Automatic pagination, filtering, sorting, field selection, search\n   - **Benefits**: Reduces boilerplate, ensures consistent query patterns\n\n2. **BaseService** (`shared/services/base.service.ts`)\n   - **Usage**: All services extend BaseService for common operations\n   - **Features**: getById, getList, create, update, delete with validation\n   - **Benefits**: Centralized business logic patterns, error handling\n\n3. **EventService** (`shared/websocket/event.service.ts`)\n   - **Usage**: Real-time WebSocket notifications for inventory changes\n   - **Features**: CRUD event helper, room-based broadcasting\n   - **Benefits**: Automatic frontend updates on stock changes\n\n4. **AppError** (`core/errors/app-error.ts`)\n   - **Usage**: Standardized error responses with error codes\n   - **Features**: HTTP status mapping, localized error messages\n   - **Benefits**: Consistent error handling across all endpoints\n\n5. **TypeBox Base Schemas** (`schemas/base.schemas.ts`)\n   - **Usage**: Pagination, sorting, filtering query schemas\n   - **Features**: ApiSuccessResponseSchema, PaginatedResponseSchema\n   - **Benefits**: Reusable schema patterns, OpenAPI documentation\n\n6. **Authentication Hooks** (`core/auth/hooks/`)\n   - **Usage**: fastify.authenticate, fastify.verifyPermission\n   - **Features**: JWT validation, RBAC enforcement\n   - **Benefits**: Secured endpoints with minimal configuration\n\n7. **Response Helpers** (`core/response/response-helper.ts`)\n   - **Usage**: reply.paginated(), reply.success(), reply.error()\n   - **Features**: Standardized response formats\n   - **Benefits**: Consistent API responses\n\n### Integration Points\n\n1. **Procurement API Integration**\n   - **Endpoint**: Receipt posting triggers inventory update\n   - **Method**: Database function `update_inventory_from_receipt(receipt_id)`\n   - **Data Flow**: Receipt items → Create lots → Update inventory → Create transactions\n   - **Error Handling**: Atomic transaction with rollback on failure\n\n2. **Distribution API Integration**\n   - **Endpoint**: Stock dispensing requests\n   - **Method**: Database functions `get_fifo_lots()`, `get_fefo_lots()`\n   - **Data Flow**: Distribution request → Select lots → Deduct quantity → Update transactions\n   - **Error Handling**: Validate stock availability before dispensing\n\n3. **Budget API Integration**\n   - **Endpoint**: Inventory valuation for budget planning\n   - **Method**: Service-to-service API call\n   - **Data Flow**: Calculate stock value → Provide to budget allocation\n   - **Error Handling**: Graceful degradation if Budget API unavailable\n\n4. **Master Data Tables**\n   - **Tables**: `inventory.drugs`, `inventory.locations`\n   - **Method**: Foreign key references with validation\n   - **Data Flow**: Validate drug_id and location_id exist before operations\n   - **Error Handling**: Return 404 if master data not found\n\n5. **Database Schema**\n   - **Schema**: `inventory` (separate from `public`)\n   - **Tables**: `inventory.inventory`, `inventory.drug_lots`, `inventory.inventory_transactions`\n   - **Functions**: `inventory.get_fifo_lots()`, `inventory.get_fefo_lots()`, `inventory.update_inventory_from_receipt()`\n   - **Views**: `inventory.low_stock_items`, `inventory.expiring_drugs`\n\n## Architecture\n\n### Overall System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        UI[Frontend Application]\n    end\n\n    subgraph \"API Layer - Fastify\"\n        Routes[Routes + Schemas]\n        Auth[Authentication Hook]\n        RBAC[Authorization Hook]\n        Controller[Controllers]\n    end\n\n    subgraph \"Business Logic Layer\"\n        Service[Services]\n        Workflow[Workflows]\n        Validation[Validation Logic]\n    end\n\n    subgraph \"Data Access Layer\"\n        Repository[Repositories]\n        DBFunctions[Database Functions]\n    end\n\n    subgraph \"Database - PostgreSQL\"\n        Tables[(Tables:<br/>inventory<br/>drug_lots<br/>inventory_transactions)]\n        Functions[(Functions:<br/>get_fifo_lots<br/>get_fefo_lots<br/>update_inventory_from_receipt)]\n    end\n\n    subgraph \"External Systems\"\n        Procurement[Procurement API]\n        Distribution[Distribution API]\n        MasterData[Master Data]\n    end\n\n    UI -->|HTTP/WebSocket| Routes\n    Routes --> Auth\n    Auth --> RBAC\n    RBAC --> Controller\n    Controller --> Service\n    Service --> Validation\n    Service --> Workflow\n    Service --> Repository\n    Repository --> Tables\n    Workflow --> DBFunctions\n    DBFunctions --> Tables\n    DBFunctions --> Functions\n\n    Procurement -->|Receipt Posted| Workflow\n    Distribution -->|Request Stock| Workflow\n    Repository -->|Validate| MasterData\n```\n\n### Modular Design Principles\n\n1. **Single File Responsibility**:\n   - Each repository handles one table's data access\n   - Each service handles one entity's business logic\n   - Each controller handles one resource's HTTP operations\n\n2. **Component Isolation**:\n   - Repositories are independent and reusable\n   - Services can be tested without database\n   - Controllers are thin HTTP adapters\n\n3. **Service Layer Separation**:\n   - **Repository**: Pure data access, no business logic\n   - **Service**: Business rules, validation, workflow orchestration\n   - **Controller**: HTTP request/response handling only\n\n4. **Utility Modularity**:\n   - FIFO/FEFO logic in database functions (reusable across services)\n   - Cost calculation utilities (weighted average)\n   - Date/time utilities for expiry calculations\n\n### Layer Responsibilities\n\n#### Repository Layer\n- Database query construction\n- Entity transformation (DB row ↔ Entity)\n- Basic CRUD operations\n- Query optimization (indexes, joins)\n\n#### Service Layer\n- Business rule enforcement\n- Multi-step workflows\n- Cross-entity operations\n- Error handling and validation\n\n#### Controller Layer\n- Request parsing and validation\n- Response formatting\n- HTTP status code mapping\n- WebSocket event emission\n\n#### Workflow Layer\n- Complex multi-step processes\n- Integration with external systems\n- Transaction management\n- Error recovery\n\n## Components and Interfaces\n\n### Component 1: InventoryRepository\n\n**Purpose:** Manages database operations for inventory table\n\n**File:** `inventory/inventory.repository.ts`\n\n**Extends:** `BaseRepository<Inventory, CreateInventory, UpdateInventory>`\n\n**Interfaces:**\n\n```typescript\nclass InventoryRepository extends BaseRepository<Inventory, CreateInventory, UpdateInventory> {\n  constructor(knex: Knex)\n\n  // Inherited from BaseRepository\n  findById(id: string | number): Promise<Inventory | null>\n  findMany(query: ListInventoryQuery): Promise<PaginatedListResult<Inventory>>\n  create(data: CreateInventory): Promise<Inventory>\n  update(id: string | number, data: UpdateInventory): Promise<Inventory>\n  delete(id: string | number): Promise<boolean>\n\n  // Custom methods\n  findByDrugAndLocation(drugId: bigint, locationId: bigint): Promise<Inventory | null>\n  findLowStock(locationId?: bigint): Promise<Inventory[]>\n  getStockValuation(locationId?: bigint): Promise<StockValuationResult>\n  updateQuantity(id: bigint, quantity: number, operation: 'add' | 'subtract'): Promise<Inventory>\n  recalculateAverageCost(id: bigint): Promise<Inventory>\n}\n```\n\n**Dependencies:**\n- Knex (database client)\n- BaseRepository\n\n**Reuses:**\n- BaseRepository for standard CRUD\n- Query builder from BaseRepository\n- Pagination logic from BaseRepository\n\n---\n\n### Component 2: InventoryService\n\n**Purpose:** Business logic for inventory management\n\n**File:** `inventory/inventory.service.ts`\n\n**Extends:** `BaseService<Inventory, CreateInventory, UpdateInventory>`\n\n**Interfaces:**\n\n```typescript\nclass InventoryService extends BaseService<Inventory, CreateInventory, UpdateInventory> {\n  constructor(\n    private inventoryRepository: InventoryRepository,\n    private drugLotsRepository: DrugLotsRepository\n  )\n\n  // Inherited from BaseService\n  getById(id: string | number): Promise<Inventory | null>\n  getList(query: ListInventoryQuery): Promise<PaginatedListResult<Inventory>>\n  create(data: CreateInventory): Promise<Inventory>\n  update(id: string | number, data: UpdateInventory): Promise<Inventory>\n  delete(id: string | number): Promise<boolean>\n\n  // Stock inquiry methods\n  getStockLevel(drugId: bigint, locationId: bigint): Promise<StockLevelDetails>\n  getLowStockItems(query: LowStockQuery): Promise<LowStockItem[]>\n  getStockValuation(query: ValuationQuery): Promise<StockValuationReport>\n\n  // Stock management methods\n  updateMinMaxLevels(id: bigint, data: MinMaxUpdate): Promise<Inventory>\n\n  // Validation methods\n  validateStockAvailability(drugId: bigint, locationId: bigint, quantity: number): Promise<boolean>\n  calculateStockStatus(inventory: Inventory): StockStatus\n  calculateDaysOfSupply(inventory: Inventory): number\n}\n```\n\n**Dependencies:**\n- InventoryRepository\n- DrugLotsRepository\n- AppError for business rule violations\n\n**Reuses:**\n- BaseService for standard operations\n- Error handling patterns from AppError\n\n---\n\n### Component 3: InventoryController\n\n**Purpose:** HTTP request handling for inventory endpoints\n\n**File:** `inventory/inventory.controller.ts`\n\n**Interfaces:**\n\n```typescript\nclass InventoryController {\n  constructor(\n    private inventoryService: InventoryService,\n    private eventService: EventService\n  )\n\n  // Phase 1: Stock Inquiry\n  async list(request: FastifyRequest, reply: FastifyReply): Promise<void>\n  async getByDrugLocation(request: FastifyRequest, reply: FastifyReply): Promise<void>\n  async getLowStock(request: FastifyRequest, reply: FastifyReply): Promise<void>\n  async getValuation(request: FastifyRequest, reply: FastifyReply): Promise<void>\n\n  // Phase 2: Stock Management\n  async updateMinMax(request: FastifyRequest, reply: FastifyReply): Promise<void>\n}\n```\n\n**Dependencies:**\n- InventoryService\n- EventService (WebSocket)\n- FastifyRequest/FastifyReply\n\n**Reuses:**\n- reply.paginated() helper\n- reply.success() helper\n- CrudEventHelper for WebSocket\n\n---\n\n### Component 4: DrugLotsRepository\n\n**Purpose:** Manages database operations for drug_lots table\n\n**File:** `drug-lots/drug-lots.repository.ts`\n\n**Extends:** `BaseRepository<DrugLot, CreateDrugLot, UpdateDrugLot>`\n\n**Interfaces:**\n\n```typescript\nclass DrugLotsRepository extends BaseRepository<DrugLot, CreateDrugLot, UpdateDrugLot> {\n  constructor(knex: Knex)\n\n  // Custom methods\n  findByDrugAndLocation(drugId: bigint, locationId: bigint, orderBy: 'FIFO' | 'FEFO'): Promise<DrugLot[]>\n  findExpiringLots(daysThreshold: number, locationId?: bigint): Promise<DrugLot[]>\n  findByLotNumber(drugId: bigint, locationId: bigint, lotNumber: string): Promise<DrugLot | null>\n  updateQuantityAvailable(id: bigint, quantity: number, operation: 'add' | 'subtract'): Promise<DrugLot>\n  deactivateLot(id: bigint): Promise<DrugLot>\n\n  // Database function wrappers\n  getFifoLots(drugId: bigint, locationId: bigint, quantityNeeded: number): Promise<FifoLotResult[]>\n  getFefoLots(drugId: bigint, locationId: bigint, quantityNeeded: number): Promise<FefoLotResult[]>\n}\n```\n\n**Dependencies:**\n- Knex\n- BaseRepository\n- Database functions (get_fifo_lots, get_fefo_lots)\n\n**Reuses:**\n- BaseRepository for CRUD\n- Query builder patterns\n\n---\n\n### Component 5: DrugLotsService\n\n**Purpose:** Business logic for lot management\n\n**File:** `drug-lots/drug-lots.service.ts`\n\n**Extends:** `BaseService<DrugLot, CreateDrugLot, UpdateDrugLot>`\n\n**Interfaces:**\n\n```typescript\nclass DrugLotsService extends BaseService<DrugLot, CreateDrugLot, UpdateDrugLot> {\n  constructor(private drugLotsRepository: DrugLotsRepository)\n\n  // Lot inquiry methods\n  getLotsByDrug(drugId: bigint, locationId: bigint, orderBy: 'FIFO' | 'FEFO'): Promise<DrugLot[]>\n  getExpiringLots(query: ExpiringLotsQuery): Promise<ExpiringLotsReport>\n  getLotDetails(id: bigint): Promise<LotDetailsWithCalculations>\n\n  // Lot management methods\n  createLotFromReceipt(receiptItem: ReceiptItem): Promise<DrugLot>\n  deductLotQuantity(lotId: bigint, quantity: number): Promise<DrugLot>\n\n  // Validation methods\n  validateLotNotExpired(lot: DrugLot): boolean\n  validateLotActive(lot: DrugLot): boolean\n  calculateExpiryStatus(expiryDate: Date): ExpiryStatus\n  calculateDaysUntilExpiry(expiryDate: Date): number\n}\n```\n\n**Dependencies:**\n- DrugLotsRepository\n- AppError\n\n**Reuses:**\n- BaseService patterns\n- Date utilities\n\n---\n\n### Component 6: InventoryTransactionsRepository\n\n**Purpose:** Manages immutable transaction log\n\n**File:** `inventory-transactions/inventory-transactions.repository.ts`\n\n**Extends:** `BaseRepository<InventoryTransaction, CreateInventoryTransaction, never>` (no updates!)\n\n**Interfaces:**\n\n```typescript\nclass InventoryTransactionsRepository extends BaseRepository<InventoryTransaction, CreateInventoryTransaction, never> {\n  constructor(knex: Knex)\n\n  // Override to prevent updates (immutable log)\n  update(): Promise<never> {\n    throw new Error('Inventory transactions are immutable')\n  }\n\n  delete(): Promise<never> {\n    throw new Error('Inventory transactions cannot be deleted')\n  }\n\n  // Custom query methods\n  findByInventory(inventoryId: bigint, query: TransactionQuery): Promise<PaginatedListResult<InventoryTransaction>>\n  findByDrugAndLocation(drugId: bigint, locationId: bigint, query: TransactionQuery): Promise<PaginatedListResult<InventoryTransaction>>\n  findByReference(referenceId: bigint, referenceType: string): Promise<InventoryTransaction[]>\n  getTransactionHistory(query: HistoryQuery): Promise<PaginatedListResult<InventoryTransaction>>\n}\n```\n\n**Dependencies:**\n- Knex\n- BaseRepository\n\n**Reuses:**\n- BaseRepository for read operations\n- Query builder for filtering\n\n---\n\n### Component 7: InventoryAdjustmentsService\n\n**Purpose:** Handles stock adjustments with validation\n\n**File:** `inventory-adjustments/inventory-adjustments.service.ts`\n\n**Interfaces:**\n\n```typescript\nclass InventoryAdjustmentsService {\n  constructor(\n    private inventoryRepository: InventoryRepository,\n    private drugLotsRepository: DrugLotsRepository,\n    private transactionsRepository: InventoryTransactionsRepository,\n    private knex: Knex\n  )\n\n  async createAdjustment(data: CreateAdjustment, userId: string): Promise<AdjustmentResult>\n  async getAdjustmentHistory(query: AdjustmentHistoryQuery): Promise<PaginatedListResult<AdjustmentRecord>>\n\n  // Private helper methods\n  private validateAdjustment(data: CreateAdjustment): Promise<void>\n  private updateInventoryQuantity(inventoryId: bigint, quantity: number, type: 'ADD' | 'SUBTRACT'): Promise<void>\n  private adjustLotQuantities(drugId: bigint, locationId: bigint, variance: number): Promise<void>\n  private createAdjustmentTransaction(data: TransactionData): Promise<InventoryTransaction>\n}\n```\n\n**Dependencies:**\n- InventoryRepository\n- DrugLotsRepository\n- InventoryTransactionsRepository\n- Knex (for transactions)\n\n**Reuses:**\n- Transaction management patterns\n- Validation utilities\n\n---\n\n### Component 8: InventoryTransfersService\n\n**Purpose:** Handles stock transfers between locations\n\n**File:** `inventory-transfers/inventory-transfers.service.ts`\n\n**Interfaces:**\n\n```typescript\nclass InventoryTransfersService {\n  constructor(\n    private inventoryRepository: InventoryRepository,\n    private drugLotsRepository: DrugLotsRepository,\n    private transactionsRepository: InventoryTransactionsRepository,\n    private knex: Knex\n  )\n\n  async createTransfer(data: CreateTransfer, userId: string): Promise<TransferResult>\n  async getTransferHistory(query: TransferHistoryQuery): Promise<PaginatedListResult<TransferRecord>>\n\n  // Private helper methods\n  private validateTransfer(data: CreateTransfer): Promise<void>\n  private selectLotsForTransfer(drugId: bigint, fromLocationId: bigint, quantity: number): Promise<FifoLotResult[]>\n  private deductFromSourceLocation(data: DeductData): Promise<void>\n  private addToDestinationLocation(data: AddData): Promise<void>\n  private createLotAtDestination(lot: FifoLotResult, destinationLocationId: bigint): Promise<DrugLot>\n  private createTransferTransactions(data: TransferTransactionData): Promise<void>\n}\n```\n\n**Dependencies:**\n- InventoryRepository\n- DrugLotsRepository\n- InventoryTransactionsRepository\n- Knex\n- Database function (get_fifo_lots)\n\n**Reuses:**\n- FIFO lot selection from database function\n- Transaction patterns\n\n---\n\n### Component 9: ReceiptPostingWorkflow\n\n**Purpose:** Automates inventory update from receipt posting\n\n**File:** `workflows/receipt-posting.workflow.ts`\n\n**Interfaces:**\n\n```typescript\nclass ReceiptPostingWorkflow {\n  constructor(\n    private inventoryRepository: InventoryRepository,\n    private drugLotsRepository: DrugLotsRepository,\n    private transactionsRepository: InventoryTransactionsRepository,\n    private knex: Knex\n  )\n\n  // Main workflow method (called by database function)\n  async processReceipt(receiptId: bigint): Promise<boolean>\n\n  // Private workflow steps\n  private fetchReceiptData(receiptId: bigint): Promise<ReceiptData>\n  private processReceiptItem(item: ReceiptItem, receipt: Receipt): Promise<void>\n  private createOrUpdateInventory(data: InventoryData): Promise<Inventory>\n  private createDrugLot(data: LotData): Promise<DrugLot>\n  private calculateAverageCost(current: Inventory, newQty: number, newCost: number): number\n  private createReceiveTransaction(data: TransactionData): Promise<InventoryTransaction>\n  private rollbackOnError(error: Error): Promise<void>\n}\n```\n\n**Dependencies:**\n- All repositories\n- Knex for atomic transactions\n- Receipt data from Procurement schema\n\n**Reuses:**\n- Transaction management\n- Cost calculation utilities\n\n---\n\n### Component 10: FifoDispensingWorkflow\n\n**Purpose:** Automates lot selection and stock deduction for distributions\n\n**File:** `workflows/fifo-dispensing.workflow.ts`\n\n**Interfaces:**\n\n```typescript\nclass FifoDispensingWorkflow {\n  constructor(\n    private inventoryRepository: InventoryRepository,\n    private drugLotsRepository: DrugLotsRepository,\n    private transactionsRepository: InventoryTransactionsRepository,\n    private knex: Knex\n  )\n\n  // Main workflow methods\n  async dispenseFifo(data: DispenseRequest): Promise<DispenseResult>\n  async dispenseFefo(data: DispenseRequest): Promise<DispenseResult>\n\n  // Private workflow steps\n  private validateStockAvailability(drugId: bigint, locationId: bigint, quantity: number): Promise<void>\n  private selectLots(drugId: bigint, locationId: bigint, quantity: number, method: 'FIFO' | 'FEFO'): Promise<FifoLotResult[]>\n  private deductFromLots(lots: FifoLotResult[], quantity: number): Promise<LotDeductionResult[]>\n  private updateInventoryQuantity(inventoryId: bigint, quantity: number): Promise<void>\n  private createIssueTransaction(data: IssueTransactionData): Promise<InventoryTransaction>\n  private deactivateDepletedLots(lots: LotDeductionResult[]): Promise<void>\n}\n```\n\n**Dependencies:**\n- All repositories\n- Knex\n- Database functions (get_fifo_lots, get_fefo_lots)\n\n**Reuses:**\n- Database FIFO/FEFO logic\n- Transaction patterns\n\n---\n\n### Component 11: ExpiryManagementWorkflow\n\n**Purpose:** Scheduled job for expiry alerts and quarantine\n\n**File:** `workflows/expiry-management.workflow.ts`\n\n**Interfaces:**\n\n```typescript\nclass ExpiryManagementWorkflow {\n  constructor(\n    private drugLotsRepository: DrugLotsRepository,\n    private transfersService: InventoryTransfersService,\n    private notificationService: NotificationService\n  )\n\n  // Main workflow method (called by cron job)\n  async checkExpiringDrugs(): Promise<ExpiryCheckResult>\n\n  // Private workflow steps\n  private findExpiringLots(daysThreshold: number): Promise<DrugLot[]>\n  private categorizeByUrgency(lots: DrugLot[]): CategorizedLots\n  private sendExpiryAlerts(categorized: CategorizedLots): Promise<void>\n  private quarantineExpiredLots(expiredLots: DrugLot[]): Promise<void>\n  private generateExpiryReport(): Promise<ExpiryReport>\n}\n```\n\n**Dependencies:**\n- DrugLotsRepository\n- InventoryTransfersService\n- NotificationService\n\n**Reuses:**\n- Transfer logic for quarantine\n- Date utilities\n\n## Data Models\n\n### Model 1: Inventory\n\n```typescript\ninterface Inventory {\n  id: bigint                    // Primary key\n  drug_id: bigint               // FK → inventory.drugs(id)\n  location_id: bigint           // FK → inventory.locations(id)\n  quantity_on_hand: number      // Current stock quantity (DECIMAL 15,3)\n  min_level?: number            // Minimum stock level (alert threshold)\n  max_level?: number            // Maximum stock level (overstock threshold)\n  reorder_point?: number        // Reorder point (when to purchase)\n  average_cost?: number         // Weighted average cost (DECIMAL 15,4)\n  last_cost?: number            // Most recent purchase cost\n  last_updated?: Date           // Last stock movement timestamp\n  created_at: Date\n  updated_at: Date\n\n  // Computed fields (not in database)\n  stock_status?: 'OK' | 'LOW' | 'CRITICAL' | 'OVERSTOCK'\n  days_of_supply?: number\n  stock_value?: number\n}\n\ninterface CreateInventory {\n  drug_id: bigint\n  location_id: bigint\n  quantity_on_hand: number\n  min_level?: number\n  max_level?: number\n  reorder_point?: number\n  average_cost?: number\n  last_cost?: number\n}\n\ninterface UpdateInventory {\n  quantity_on_hand?: number\n  min_level?: number\n  max_level?: number\n  reorder_point?: number\n  average_cost?: number\n  last_cost?: number\n  last_updated?: Date\n}\n\n// Unique constraint: (drug_id, location_id)\n// Business rule: quantity_on_hand >= 0\n// Business rule: min_level < reorder_point < max_level (if all specified)\n```\n\n### Model 2: DrugLot\n\n```typescript\ninterface DrugLot {\n  id: bigint                    // Primary key\n  drug_id: bigint               // FK → inventory.drugs(id)\n  location_id: bigint           // FK → inventory.locations(id)\n  lot_number: string            // Manufacturer lot number (VARCHAR 50)\n  expiry_date: Date             // Expiration date\n  quantity_available: number    // Remaining quantity in lot (DECIMAL 15,3)\n  unit_cost: number             // Cost per unit for this lot (DECIMAL 15,4)\n  received_date: Date           // Date lot was received\n  receipt_id?: bigint           // FK → procurement.receipts(id)\n  is_active: boolean            // FALSE when lot depleted\n  created_at: Date\n  updated_at: Date\n\n  // Computed fields\n  is_expired?: boolean\n  days_until_expiry?: number\n  expiry_status?: 'OK' | 'WARN' | 'CRITICAL' | 'EXPIRED'\n  dispensed_quantity?: number\n  utilization_percent?: number\n}\n\ninterface CreateDrugLot {\n  drug_id: bigint\n  location_id: bigint\n  lot_number: string\n  expiry_date: Date\n  quantity_available: number\n  unit_cost: number\n  received_date: Date\n  receipt_id?: bigint\n  is_active?: boolean\n}\n\ninterface UpdateDrugLot {\n  quantity_available?: number\n  is_active?: boolean\n}\n\n// Unique constraint: (drug_id, location_id, lot_number)\n// Business rule: quantity_available >= 0\n// Business rule: expiry_date > received_date\n// Business rule: is_active = FALSE when quantity_available = 0\n```\n\n### Model 3: InventoryTransaction\n\n```typescript\ntype TransactionType = 'RECEIVE' | 'ISSUE' | 'TRANSFER' | 'ADJUST' | 'RETURN'\n\ninterface InventoryTransaction {\n  id: bigint                    // Primary key\n  inventory_id: bigint          // FK → inventory.inventory(id)\n  transaction_type: TransactionType\n  quantity: number              // Quantity moved (+ or -, DECIMAL 15,3)\n  unit_cost?: number            // Cost per unit (for costing, DECIMAL 15,4)\n  reference_id?: bigint         // ID of source document\n  reference_type?: string       // Type: receipt, distribution, return, adjustment\n  notes?: string                // Transaction notes/reason\n  created_by: string            // User who created transaction\n  created_at: Date              // Transaction timestamp (immutable)\n}\n\ninterface CreateInventoryTransaction {\n  inventory_id: bigint\n  transaction_type: TransactionType\n  quantity: number\n  unit_cost?: number\n  reference_id?: bigint\n  reference_type?: string\n  notes?: string\n  created_by: string\n}\n\n// IMMUTABLE: No updates or deletes allowed\n// Business rule: reference_id + reference_type must be valid\n// Business rule: quantity can be positive or negative depending on type\n```\n\n### Model 4: FIFO/FEFO Result (Database Function Output)\n\n```typescript\ninterface FifoLotResult {\n  lot_id: bigint\n  lot_number: string\n  quantity: number        // Quantity to dispense from this lot\n  unit_cost: number\n}\n\ninterface FefoLotResult {\n  lot_id: bigint\n  lot_number: string\n  expiry_date: Date\n  quantity: number        // Quantity to dispense from this lot\n}\n```\n\n### Model 5: Stock Level Details (Computed)\n\n```typescript\ninterface StockLevelDetails {\n  inventory: Inventory\n  drug: {\n    drug_code: string\n    trade_name: string\n    unit_price: number\n  }\n  location: {\n    location_code: string\n    location_name: string\n  }\n  stock_status: 'OK' | 'LOW' | 'CRITICAL' | 'OVERSTOCK'\n  days_of_supply: number\n  stock_value: number\n  active_lots_count: number\n  oldest_expiry_date?: Date\n}\n```\n\n### Model 6: Low Stock Item (Report)\n\n```typescript\ninterface LowStockItem {\n  drug_id: bigint\n  location_id: bigint\n  current_stock: number\n  min_level: number\n  reorder_point: number\n  reorder_quantity: number\n  urgency: 'LOW' | 'CRITICAL'\n  drug: {\n    drug_code: string\n    trade_name: string\n    unit_price: number\n  }\n  location: {\n    location_name: string\n  }\n  days_of_supply: number\n  average_daily_usage: number\n  suggested_order_quantity: number\n  last_received_date?: Date\n  days_since_last_received?: number\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **STOCK_NOT_FOUND**\n   - **Description**: Inventory record doesn't exist for drug/location combination\n   - **HTTP Status**: 404 Not Found\n   - **Handling**: Check if inventory.findByDrugAndLocation() returns null\n   - **User Impact**: \"Stock record not found for this drug at this location\"\n   - **Recovery**: Create initial inventory record or verify drug/location IDs\n\n2. **INSUFFICIENT_STOCK**\n   - **Description**: Requested quantity exceeds available quantity\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Validate quantity_on_hand >= requested_quantity before operation\n   - **User Impact**: \"Insufficient stock. Available: 500, Requested: 1000\"\n   - **Recovery**: User reduces requested quantity or transfers from another location\n\n3. **LOT_NOT_FOUND**\n   - **Description**: Specified lot ID doesn't exist\n   - **HTTP Status**: 404 Not Found\n   - **Handling**: Check if drugLotsRepository.findById() returns null\n   - **User Impact**: \"Lot record not found\"\n   - **Recovery**: Verify lot ID or search for available lots\n\n4. **LOT_EXPIRED**\n   - **Description**: Attempting to use a lot past its expiry date\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Check lot.expiry_date < current_date before dispensing\n   - **User Impact**: \"Cannot dispense expired lot. Expiry date: 2024-06-01\"\n   - **Recovery**: Use FEFO to dispense unexpired lots first, quarantine expired lot\n\n5. **LOT_DEPLETED**\n   - **Description**: Lot has zero remaining quantity\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Check lot.quantity_available > 0 before deduction\n   - **User Impact**: \"Lot has no remaining quantity\"\n   - **Recovery**: Select next FIFO/FEFO lot automatically\n\n6. **NEGATIVE_STOCK**\n   - **Description**: Operation would result in negative quantity_on_hand\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Check (current_qty - deduct_qty) >= 0 before update\n   - **User Impact**: \"Operation would result in negative stock\"\n   - **Recovery**: Validate calculations, check for concurrent updates\n\n7. **INVALID_ADJUSTMENT_REASON**\n   - **Description**: Adjustment reason ID doesn't exist in lookup table\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Validate adjustment_reason_id exists before creating adjustment\n   - **User Impact**: \"Invalid adjustment reason\"\n   - **Recovery**: User selects valid reason from dropdown\n\n8. **MIN_MAX_VIOLATION**\n   - **Description**: min_level >= max_level or reorder_point outside range\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Validate min < reorder < max before update\n   - **User Impact**: \"Min level must be less than max level\"\n   - **Recovery**: User corrects min/max values\n\n9. **TRANSFER_SAME_LOCATION**\n   - **Description**: Source and destination locations are identical\n   - **HTTP Status**: 400 Bad Request\n   - **Handling**: Check from_location_id !== to_location_id\n   - **User Impact**: \"Cannot transfer to the same location\"\n   - **Recovery**: User selects different destination\n\n10. **RECEIPT_ALREADY_POSTED**\n    - **Description**: Receipt has already been posted to inventory\n    - **HTTP Status**: 409 Conflict\n    - **Handling**: Check receipt.posted_at IS NOT NULL before processing\n    - **User Impact**: \"Receipt has already been posted\"\n    - **Recovery**: Idempotency - return existing result\n\n### Error Response Format\n\nAll errors follow standardized format:\n\n```typescript\n{\n  success: false,\n  error: {\n    code: \"INSUFFICIENT_STOCK\",\n    message: \"Insufficient stock. Available: 500, Requested: 1000\",\n    details: {\n      drug_id: 1,\n      location_id: 2,\n      requested: 1000,\n      available: 500,\n      shortage: 500\n    },\n    timestamp: \"2025-12-14T13:30:00Z\",\n    correlationId: \"abc123\"\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Tool**: Vitest\n\n**Coverage Target**: 80% minimum\n\n**Key Components to Test**:\n\n1. **Repository Tests** (`*.repository.spec.ts`)\n   - Test data transformation (DB row ↔ Entity)\n   - Test query building with filters, sorting, pagination\n   - Test custom methods (findByDrugAndLocation, getFifoLots)\n   - Mock Knex for database operations\n\n2. **Service Tests** (`*.service.spec.ts`)\n   - Test business logic in isolation\n   - Test validation rules (min < reorder < max)\n   - Test error handling (INSUFFICIENT_STOCK)\n   - Test calculations (average cost, days of supply)\n   - Mock repositories\n\n3. **Controller Tests** (`*.controller.spec.ts`)\n   - Test request parsing and validation\n   - Test response formatting\n   - Test error responses (400, 404, 500)\n   - Mock services\n\n**Example Test Structure**:\n\n```typescript\ndescribe('InventoryService', () => {\n  let service: InventoryService\n  let mockRepository: MockInventoryRepository\n\n  beforeEach(() => {\n    mockRepository = createMockRepository()\n    service = new InventoryService(mockRepository)\n  })\n\n  describe('validateStockAvailability', () => {\n    it('should return true when stock is sufficient', async () => {\n      mockRepository.findByDrugAndLocation.mockResolvedValue({\n        id: 1n,\n        quantity_on_hand: 1000\n      })\n\n      const result = await service.validateStockAvailability(1n, 2n, 500)\n      expect(result).toBe(true)\n    })\n\n    it('should throw INSUFFICIENT_STOCK when quantity exceeds available', async () => {\n      mockRepository.findByDrugAndLocation.mockResolvedValue({\n        id: 1n,\n        quantity_on_hand: 500\n      })\n\n      await expect(\n        service.validateStockAvailability(1n, 2n, 1000)\n      ).rejects.toThrow('INSUFFICIENT_STOCK')\n    })\n  })\n})\n```\n\n### Integration Testing\n\n**Tool**: Vitest + TestContainers (PostgreSQL)\n\n**Key Flows to Test**:\n\n1. **Receipt Posting Flow**\n   - Create receipt in Procurement schema\n   - Call update_inventory_from_receipt()\n   - Verify inventory created/updated\n   - Verify lot created\n   - Verify transaction logged\n\n2. **FIFO Dispensing Flow**\n   - Create inventory with 3 lots (different received dates)\n   - Request stock via get_fifo_lots()\n   - Verify lots returned in FIFO order\n   - Verify quantities deducted correctly\n   - Verify depleted lots deactivated\n\n3. **Stock Adjustment Flow**\n   - Create stock adjustment (SUBTRACT 100)\n   - Verify inventory quantity reduced\n   - Verify transaction created with type ADJUST\n   - Verify audit trail intact\n\n4. **Transfer Flow**\n   - Create transfer from Location A to Location B\n   - Verify source inventory reduced\n   - Verify destination inventory increased\n   - Verify lots created at destination\n   - Verify two transactions created\n\n**Example Integration Test**:\n\n```typescript\ndescribe('Receipt Posting Integration', () => {\n  let db: Knex\n  let workflow: ReceiptPostingWorkflow\n\n  beforeAll(async () => {\n    db = await setupTestDatabase()\n    workflow = new ReceiptPostingWorkflow(/* ... */)\n  })\n\n  it('should create inventory and lot from receipt', async () => {\n    // Arrange: Create receipt with items\n    const receipt = await createTestReceipt(db, {\n      items: [{\n        drug_id: 1n,\n        lot_number: 'LOT2025001',\n        expiry_date: '2027-12-31',\n        quantity: 1000,\n        unit_price: 2.50\n      }]\n    })\n\n    // Act: Post receipt\n    await workflow.processReceipt(receipt.id)\n\n    // Assert: Verify inventory created\n    const inventory = await db('inventory.inventory')\n      .where({ drug_id: 1, location_id: 2 })\n      .first()\n\n    expect(inventory.quantity_on_hand).toBe(1000)\n    expect(inventory.average_cost).toBe(2.50)\n\n    // Assert: Verify lot created\n    const lot = await db('inventory.drug_lots')\n      .where({ lot_number: 'LOT2025001' })\n      .first()\n\n    expect(lot.quantity_available).toBe(1000)\n    expect(lot.expiry_date).toBe('2027-12-31')\n\n    // Assert: Verify transaction created\n    const transaction = await db('inventory.inventory_transactions')\n      .where({ inventory_id: inventory.id })\n      .first()\n\n    expect(transaction.transaction_type).toBe('RECEIVE')\n    expect(transaction.quantity).toBe(1000)\n  })\n})\n```\n\n### End-to-End Testing\n\n**Tool**: Playwright (via frontend tests)\n\n**User Scenarios to Test**:\n\n1. **Scenario: View Stock Levels**\n   - Login as Pharmacist\n   - Navigate to Inventory → Stock Levels\n   - Filter by location (Central Pharmacy)\n   - Verify stock data displayed correctly\n   - Verify low stock items highlighted\n\n2. **Scenario: Create Stock Adjustment**\n   - Login as Inventory Manager\n   - Navigate to Inventory → Adjustments\n   - Select drug and location\n   - Enter adjustment (SUBTRACT 500)\n   - Select reason (Damaged)\n   - Submit adjustment\n   - Verify success message\n   - Verify stock updated on Stock Levels page\n\n3. **Scenario: Transfer Stock Between Locations**\n   - Login as Warehouse Supervisor\n   - Navigate to Inventory → Transfers\n   - Select drug, source (Warehouse), destination (Pharmacy)\n   - Enter quantity (1000)\n   - Submit transfer\n   - Verify success message\n   - Verify source stock reduced\n   - Verify destination stock increased\n\n**Example E2E Test**:\n\n```typescript\ntest('pharmacist can view low stock items', async ({ page }) => {\n  // Login\n  await page.goto('/login')\n  await page.fill('[name=\"username\"]', 'pharmacist1')\n  await page.fill('[name=\"password\"]', 'password123')\n  await page.click('button[type=\"submit\"]')\n\n  // Navigate to Low Stock\n  await page.goto('/inventory/low-stock')\n\n  // Verify page loaded\n  await expect(page.locator('h1')).toContainText('Low Stock Items')\n\n  // Verify low stock items displayed\n  const items = page.locator('[data-testid=\"low-stock-item\"]')\n  await expect(items).toHaveCount.greaterThan(0)\n\n  // Verify critical urgency highlighted\n  const criticalItems = page.locator('[data-urgency=\"CRITICAL\"]')\n  await expect(criticalItems.first()).toHaveClass(/text-red-600/)\n\n  // Verify reorder quantity suggested\n  const firstItem = items.first()\n  await expect(firstItem.locator('[data-testid=\"suggested-qty\"]')).toBeVisible()\n})\n```\n\n## Performance Optimization\n\n### Database Indexes\n\n```sql\n-- inventory table\nCREATE INDEX idx_inventory_drug ON inventory.inventory(drug_id);\nCREATE INDEX idx_inventory_location ON inventory.inventory(location_id);\nCREATE INDEX idx_inventory_reorder ON inventory.inventory(reorder_point)\n  WHERE quantity_on_hand <= reorder_point;\n\n-- drug_lots table\nCREATE INDEX idx_drug_lots_drug ON inventory.drug_lots(drug_id);\nCREATE INDEX idx_drug_lots_location ON inventory.drug_lots(location_id);\nCREATE INDEX idx_drug_lots_expiry ON inventory.drug_lots(expiry_date)\n  WHERE is_active = TRUE;\nCREATE INDEX idx_drug_lots_fifo ON inventory.drug_lots(drug_id, location_id, received_date)\n  WHERE quantity_available > 0;\nCREATE INDEX idx_drug_lots_fefo ON inventory.drug_lots(drug_id, location_id, expiry_date)\n  WHERE quantity_available > 0;\n\n-- inventory_transactions table\nCREATE INDEX idx_inv_trans_inventory ON inventory.inventory_transactions(inventory_id);\nCREATE INDEX idx_inv_trans_type ON inventory.inventory_transactions(transaction_type);\nCREATE INDEX idx_inv_trans_reference ON inventory.inventory_transactions(reference_id, reference_type);\nCREATE INDEX idx_inv_trans_created ON inventory.inventory_transactions(created_at DESC);\nCREATE INDEX idx_inv_trans_user ON inventory.inventory_transactions(created_by);\n```\n\n### Query Optimization\n\n1. **Use Database Functions**: FIFO/FEFO logic in PostgreSQL for better performance\n2. **Pagination**: Default limit 50, max 200 records per page\n3. **Field Selection**: Support `fields` parameter to reduce data transfer\n4. **Eager Loading**: Join drug and location data in single query when needed\n5. **Caching**: Cache master data (drugs, locations) for 5 minutes\n\n### Response Time Targets\n\n- Stock list query: < 500ms for 10,000 records\n- FIFO/FEFO lot selection: < 200ms\n- Receipt posting: < 2 seconds for 50 line items\n- Transaction history: < 300ms for 1000 transactions\n\n## Security Considerations\n\n### Authentication & Authorization\n\nAll endpoints require:\n1. **JWT Authentication**: `fastify.authenticate` hook\n2. **RBAC**: `fastify.verifyPermission(resource, action)` hook\n\n**Permission Matrix**:\n\n| Endpoint | Resource | Action | Roles |\n|----------|----------|--------|-------|\n| GET /stock | inventory | read | ADMIN, PHARMACIST, INVENTORY_STAFF, DEPARTMENT_USER |\n| PUT /stock/:id/min-max | inventory | update | ADMIN, PHARMACIST, INVENTORY_STAFF |\n| POST /adjustments | inventory_adjustments | create | ADMIN, PHARMACIST, INVENTORY_STAFF |\n| GET /adjustments | inventory_adjustments | read | ADMIN, PHARMACIST, INVENTORY_STAFF |\n| POST /transfers | inventory_transfers | create | ADMIN, INVENTORY_STAFF |\n| GET /low-stock | inventory | read | ADMIN, PHARMACIST, PROCUREMENT_OFFICER |\n| GET /transactions | inventory_transactions | read | ADMIN, FINANCE_OFFICER |\n| GET /valuation | inventory_valuation | read | ADMIN, FINANCE_OFFICER |\n\n### Data Validation\n\n1. **TypeBox Schemas**: All inputs validated against schemas\n2. **SQL Injection Prevention**: Knex query builder (parameterized queries)\n3. **XSS Prevention**: Input sanitization, output encoding\n4. **UUID Validation**: BaseRepository validates UUID fields\n5. **Business Rule Validation**: Service layer enforces min < reorder < max, qty >= 0\n\n### Audit Trail\n\n1. **Immutable Transactions**: No updates/deletes on inventory_transactions\n2. **User Tracking**: created_by field on all adjustments and transfers\n3. **Timestamp Tracking**: created_at on all records\n4. **Correlation IDs**: Request correlation for troubleshooting\n5. **Change Log**: WebSocket events broadcast all changes for audit\n\n## WebSocket Real-Time Updates\n\n### Event Types\n\n```typescript\n// Stock level changed\n{\n  event: 'inventory:stock_updated',\n  data: {\n    inventory_id: 123,\n    drug_id: 1,\n    location_id: 2,\n    old_quantity: 1000,\n    new_quantity: 1500,\n    stock_status: 'OK'\n  }\n}\n\n// Lot created\n{\n  event: 'inventory:lot_created',\n  data: {\n    lot_id: 456,\n    drug_id: 1,\n    location_id: 2,\n    lot_number: 'LOT2025001',\n    quantity: 1000,\n    expiry_date: '2027-12-31'\n  }\n}\n\n// Low stock alert\n{\n  event: 'inventory:low_stock_alert',\n  data: {\n    drug_id: 1,\n    location_id: 2,\n    current_stock: 450,\n    reorder_point: 500,\n    urgency: 'CRITICAL'\n  }\n}\n\n// Expiry alert\n{\n  event: 'inventory:expiry_alert',\n  data: {\n    lot_id: 789,\n    drug_id: 2,\n    expiry_date: '2025-03-15',\n    days_until_expiry: 25,\n    quantity_remaining: 300\n  }\n}\n```\n\n### Room-Based Broadcasting\n\n```typescript\n// Broadcast to location-specific room\neventService.for('inventory', 'stock')\n  .broadcast(`location:${locationId}`, 'stock_updated', data)\n\n// Broadcast to drug-specific room\neventService.for('inventory', 'lot')\n  .broadcast(`drug:${drugId}`, 'lot_created', data)\n\n// Broadcast to all inventory managers\neventService.for('inventory', 'alert')\n  .broadcast('role:inventory_manager', 'low_stock_alert', data)\n```\n\n## Deployment Considerations\n\n### Database Migration\n\n1. **Create schema**: `CREATE SCHEMA IF NOT EXISTS inventory`\n2. **Run migrations**: Execute all migrations in `migrations-inventory/` folder\n3. **Create functions**: Deploy FIFO/FEFO database functions\n4. **Create views**: Deploy low_stock_items, expiring_drugs views\n5. **Seed master data**: Run seed script for drugs, locations\n\n### Environment Variables\n\n```env\n# Database\nDATABASE_URL=postgresql://user:password@localhost:5434/invs_modern\nDATABASE_SCHEMA=inventory\n\n# Inventory Configuration\nINVENTORY_ALLOW_NEGATIVE_STOCK=false\nINVENTORY_EXPIRY_WARNING_DAYS=180\nINVENTORY_EXPIRY_CRITICAL_DAYS=90\nINVENTORY_DEFAULT_DISPENSING_METHOD=FEFO\n\n# Performance\nINVENTORY_QUERY_TIMEOUT=30000\nINVENTORY_DEFAULT_PAGE_LIMIT=50\nINVENTORY_MAX_PAGE_LIMIT=200\n\n# Caching\nINVENTORY_CACHE_MASTER_DATA=true\nINVENTORY_CACHE_TTL=300\n\n# Monitoring\nINVENTORY_LOG_LEVEL=info\nINVENTORY_ENABLE_METRICS=true\n```\n\n### Health Checks\n\n```typescript\n// Health check endpoint\nfastify.get('/health/inventory', async (request, reply) => {\n  const checks = {\n    database: await checkDatabaseConnection(),\n    schema: await checkSchemaExists(),\n    functions: await checkDatabaseFunctions(),\n  }\n\n  const healthy = Object.values(checks).every(check => check.status === 'ok')\n\n  return reply.code(healthy ? 200 : 503).send({\n    status: healthy ? 'healthy' : 'unhealthy',\n    checks\n  })\n})\n```\n\n## Future Enhancements\n\n1. **Batch Operations**: Bulk adjustments, bulk transfers\n2. **Advanced Reporting**: ABC-VEN analysis, usage forecasting\n3. **Mobile API**: Optimized endpoints for mobile stock taking\n4. **Barcode Integration**: Scan barcodes for quick stock updates\n5. **AI-Powered Reordering**: Machine learning for optimal reorder points\n6. **Multi-Hospital Support**: Sharding by hospital_id for scale\n7. **Offline Support**: Sync mechanism for disconnected operations\n8. **Advanced Alerts**: Custom alert rules, escalation workflows\n",
  "fileStats": {
    "size": 46309,
    "lines": 1456,
    "lastModified": "2025-12-14T13:16:13.466Z"
  },
  "comments": []
}