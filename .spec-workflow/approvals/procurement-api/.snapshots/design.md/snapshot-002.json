{
  "id": "snapshot_1765717945281_fy41jpt9s",
  "approvalId": "approval_1765717925445_9d8t1u20v",
  "approvalTitle": "Procurement API - Design Document",
  "version": 2,
  "timestamp": "2025-12-14T13:12:25.281Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document - Procurement API\n\n## Overview\n\nThe Procurement API extends the existing CRUD-based procurement modules with comprehensive **workflow orchestration** and **cross-system integration**. This design leverages the foundational 8 procurement modules already implemented (Purchase Requests, Purchase Orders, Receipts, Contracts, etc.) and adds workflow services to enable the complete procurement cycle with budget control and inventory integration.\n\n**Architecture Approach:**\n- **Reuse Existing**: 8 CRUD modules provide solid foundation (controllers, services, repositories, routes)\n- **Add Workflow Services**: New service layer for workflow orchestration (submit, approve, send, post)\n- **External Integration**: Budget API client for financial controls, Inventory updates for stock management\n- **Transaction Management**: Prisma transactions ensure atomic multi-step operations\n- **Event-Driven**: Optional WebSocket events for real-time UI updates\n\n**System Position:**\nThe Procurement API acts as the **orchestration layer** between:\n- **Upstream**: Budget Management (budget checking, reservations, commitments)\n- **Downstream**: Inventory Management (lot creation, stock updates)\n- **Core**: Procurement workflow state machine (PR → PO → Receipt → Payment)\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**AegisX Platform Standards:**\n1. **Service Layer Pattern**: Extends `BaseService<T, CreateDto, UpdateDto>` for standard CRUD, adds workflow services for business logic\n2. **TypeBox Schema Validation**: All request/response validated with TypeBox schemas before processing\n3. **Repository Pattern**: Data access through repositories, never direct Prisma calls in controllers\n4. **Fastify Plugins**: Each workflow service registered as Fastify decorator for dependency injection\n5. **Error Handling**: Custom error classes with proper HTTP status codes and i18n messages\n6. **Logging**: Structured logging with `request.log` including correlation IDs\n7. **Transaction Management**: All multi-step operations wrapped in `prisma.$transaction()`\n\n**TypeScript Standards:**\n- Strict mode enabled, no `any` types\n- Interface-first design for all service contracts\n- Type exports from `.types.ts` files\n- Generic types for reusable patterns\n\n**Testing Standards:**\n- Unit tests for all service methods (target: 80% coverage)\n- Integration tests for workflow endpoints\n- Mock external dependencies (Budget API, Inventory API)\n\n### Project Structure (structure.md)\n\n**Module Organization:**\n```\napps/api/src/modules/inventory/procurement/\n├── purchaseRequests/\n│   ├── purchase-requests.controller.ts      # Existing CRUD controller\n│   ├── purchase-requests.service.ts         # Existing CRUD service\n│   ├── purchase-requests.repository.ts      # Existing repository\n│   ├── purchase-requests.routes.ts          # Extended with workflow routes\n│   ├── purchase-requests.schemas.ts         # Extended with workflow schemas\n│   ├── purchase-requests.types.ts           # Existing types\n│   └── purchase-requests-workflow.service.ts # NEW - Workflow orchestration\n├── purchaseOrders/\n│   ├── purchase-orders.controller.ts        # Existing CRUD controller\n│   ├── purchase-orders.service.ts           # Existing CRUD service\n│   ├── purchase-orders.repository.ts        # Existing repository\n│   ├── purchase-orders.routes.ts            # Extended with workflow routes\n│   ├── purchase-orders.schemas.ts           # Extended with workflow schemas\n│   ├── purchase-orders.types.ts             # Existing types\n│   └── purchase-orders-workflow.service.ts  # NEW - Workflow orchestration\n├── receipts/\n│   ├── receipts.controller.ts               # Existing CRUD controller\n│   ├── receipts.service.ts                  # Existing CRUD service\n│   ├── receipts.repository.ts               # Existing repository\n│   ├── receipts.routes.ts                   # Extended with workflow routes\n│   ├── receipts.schemas.ts                  # Extended with workflow schemas\n│   ├── receipts.types.ts                    # Existing types\n│   └── receipts-workflow.service.ts         # NEW - Workflow orchestration\n└── shared/\n    ├── budget-integration.service.ts        # NEW - Budget API client\n    ├── inventory-integration.service.ts     # NEW - Inventory API client\n    ├── contract-pricing.service.ts          # NEW - Contract price lookup\n    └── procurement.types.ts                 # NEW - Shared types\n```\n\n**Shared Services Location:**\n```\napps/api/src/shared/services/\n├── base.service.ts                          # Existing - Extended\n└── http-client.service.ts                   # NEW - For external API calls\n```\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n1. **BaseService<T, CreateDto, UpdateDto>**\n   - Location: `apps/api/src/shared/services/base.service.ts`\n   - Usage: All 8 existing procurement services extend this for standard CRUD\n   - Hooks Used: `validateCreate`, `beforeCreate`, `afterCreate`, `validateUpdate`, `beforeUpdate`, `afterUpdate`\n   - **Our Approach**: Workflow services will **use existing services** but won't extend BaseService (composition over inheritance)\n\n2. **BaseRepository<T, CreateDto, UpdateDto>**\n   - Location: `apps/api/src/shared/repositories/base.repository.ts`\n   - Usage: All repositories extend for database operations\n   - Methods: `findById`, `list`, `create`, `update`, `delete`\n   - **Our Approach**: Workflow services use existing repositories through existing services\n\n3. **TypeBox Schema Validation**\n   - Pattern: All routes use TypeBox schemas for validation\n   - Location: `*.schemas.ts` files in each module\n   - **Our Approach**: Create new workflow schemas (SubmitPRSchema, ApprovePRSchema, SendPOSchema, PostReceiptSchema)\n\n4. **Fastify Plugin Architecture**\n   - Pattern: Each module is a Fastify plugin with dependency injection\n   - Registration: Via `fastify.register()` in main app\n   - **Our Approach**: Register workflow services as Fastify decorators (`fastify.decorate('prWorkflowService', ...)`)\n\n5. **Reply Helper Extensions**\n   - Methods: `reply.success()`, `reply.error()`, `reply.notFound()`, `reply.unauthorized()`, `reply.forbidden()`\n   - Location: `apps/api/src/plugins/response-handler.plugin.ts`\n   - **Our Approach**: Use existing reply helpers for consistent responses\n\n6. **Prisma Client**\n   - Location: `apps/api/src/database/prisma.client.ts`\n   - Transaction Support: `prisma.$transaction(async (tx) => {...})`\n   - **Our Approach**: Use Prisma transactions for all workflow operations\n\n7. **Logger**\n   - Fastify's built-in logger: `request.log.info()`, `request.log.error()`\n   - **Our Approach**: Structured logging with context (userId, prId, action)\n\n### Existing Components to Extend\n\n1. **Purchase Requests Service**\n   - Location: `apps/api/src/modules/inventory/procurement/purchaseRequests/purchase-requests.service.ts`\n   - Current: CRUD operations only\n   - Extension: Keep CRUD, add separate `PurchaseRequestWorkflowService` for submit/approve/reject\n\n2. **Purchase Requests Routes**\n   - Location: `apps/api/src/modules/inventory/procurement/purchaseRequests/purchase-requests.routes.ts`\n   - Current: CRUD routes (GET, POST, PUT, DELETE /purchase-requests)\n   - Extension: Add workflow routes:\n     - `POST /purchase-requests/:id/submit`\n     - `POST /purchase-requests/:id/approve`\n     - `POST /purchase-requests/:id/reject`\n\n3. **Purchase Orders Service & Routes**\n   - Extension: Add `PurchaseOrderWorkflowService` and workflow routes:\n     - `POST /purchase-orders/:id/approve`\n     - `POST /purchase-orders/:id/send`\n     - `POST /purchase-orders/:id/cancel`\n\n4. **Receipts Service & Routes**\n   - Extension: Add `ReceiptsWorkflowService` and workflow routes:\n     - `POST /receipts/:id/post`\n\n### Integration Points\n\n1. **Budget Management API Integration**\n   - External API: Separate Budget Management module (may be separate microservice or same codebase)\n   - Endpoints to Call:\n     - `POST /api/budget/check-availability` - Check if budget available\n     - `POST /api/budget/reserve` - Reserve budget for PR\n     - `POST /api/budget/commit` - Commit budget when PO sent\n     - `POST /api/budget/release-reservation` - Release reservation when PR rejected\n     - `POST /api/budget/release-commitment` - Release commitment when PO cancelled\n   - **Integration Service**: `BudgetIntegrationService` with retry logic and timeout handling\n\n2. **Inventory Management Integration**\n   - Database Tables: `inventory`, `drug_lots`, `inventory_transactions` (same database)\n   - Direct Prisma Updates: No external API calls, use Prisma transactions\n   - Operations:\n     - Create `drug_lots` records when receipt posted\n     - Update/Create `inventory` records (upsert by drug_id + location_id)\n     - Create `inventory_transactions` with type='RECEIVE'\n   - **Integration Service**: `InventoryIntegrationService` for encapsulated logic\n\n3. **Contract Pricing Integration**\n   - Database Tables: `contracts`, `contract_items` (same database, already exist)\n   - Query Pattern: Join contracts with contract_items to find agreed prices\n   - **Integration Service**: `ContractPricingService` with caching (Redis)\n\n4. **Notification System**\n   - Existing: Email/notification service (assumed to exist)\n   - Usage: Notify managers on PR submission, notify requester on approval/rejection\n   - **Approach**: Call existing notification service (if available) or implement simple email sending\n\n## Architecture\n\n### High-Level Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        UI[Frontend UI]\n    end\n\n    subgraph \"API Gateway\"\n        Routes[Fastify Routes]\n    end\n\n    subgraph \"Controller Layer\"\n        PRController[PR Controller<br/>CRUD + Workflow]\n        POController[PO Controller<br/>CRUD + Workflow]\n        ReceiptController[Receipt Controller<br/>CRUD + Workflow]\n    end\n\n    subgraph \"Workflow Service Layer\"\n        PRWorkflow[PR Workflow Service<br/>submit/approve/reject]\n        POWorkflow[PO Workflow Service<br/>approve/send/cancel]\n        ReceiptWorkflow[Receipt Workflow Service<br/>post]\n    end\n\n    subgraph \"Business Service Layer\"\n        PRService[PR Service<br/>CRUD]\n        POService[PO Service<br/>CRUD]\n        ReceiptService[Receipt Service<br/>CRUD]\n        ContractService[Contract Service]\n    end\n\n    subgraph \"Integration Service Layer\"\n        BudgetIntegration[Budget Integration<br/>reserve/commit/release]\n        InventoryIntegration[Inventory Integration<br/>lots/stock updates]\n        ContractPricing[Contract Pricing<br/>price lookup + cache]\n    end\n\n    subgraph \"Repository Layer\"\n        PRRepo[PR Repository]\n        PORepo[PO Repository]\n        ReceiptRepo[Receipt Repository]\n        ContractRepo[Contract Repository]\n    end\n\n    subgraph \"External Systems\"\n        BudgetAPI[Budget API]\n        Prisma[(PostgreSQL<br/>Prisma)]\n        Redis[(Redis Cache)]\n    end\n\n    UI --> Routes\n    Routes --> PRController\n    Routes --> POController\n    Routes --> ReceiptController\n\n    PRController --> PRWorkflow\n    POController --> POWorkflow\n    ReceiptController --> ReceiptWorkflow\n\n    PRWorkflow --> PRService\n    PRWorkflow --> BudgetIntegration\n    POWorkflow --> POService\n    POWorkflow --> BudgetIntegration\n    POWorkflow --> ContractPricing\n    ReceiptWorkflow --> ReceiptService\n    ReceiptWorkflow --> InventoryIntegration\n\n    PRService --> PRRepo\n    POService --> PORepo\n    ReceiptService --> ReceiptRepo\n    ContractPricing --> ContractService\n\n    ContractService --> ContractRepo\n\n    PRRepo --> Prisma\n    PORepo --> Prisma\n    ReceiptRepo --> Prisma\n    ContractRepo --> Prisma\n\n    BudgetIntegration --> BudgetAPI\n    ContractPricing --> Redis\n    InventoryIntegration --> Prisma\n```\n\n### Modular Design Principles\n\n**1. Single File Responsibility**\n- **Workflow Services**: One file per workflow domain (PR, PO, Receipt)\n- **Integration Services**: One file per external system (Budget, Inventory, Contract)\n- **Controllers**: Workflow methods added to existing controllers (no new controller files)\n- **Routes**: Workflow routes added to existing route files\n\n**2. Component Isolation**\n- Each workflow service is independently testable with mocked dependencies\n- Integration services have clear interfaces (TypeScript interfaces)\n- No circular dependencies between services\n\n**3. Service Layer Separation**\n- **Controller Layer**: Request/response handling, schema validation, logging\n- **Workflow Service Layer**: Business logic orchestration, transaction management\n- **Business Service Layer**: CRUD operations (existing services)\n- **Integration Service Layer**: External API calls, database updates\n- **Repository Layer**: Raw database access (existing repositories)\n\n**4. Utility Modularity**\n- **HTTP Client**: Reusable HTTP client for external API calls (Budget API)\n- **Error Handlers**: Centralized error mapping (BudgetError, WorkflowError)\n- **Validators**: Shared validation helpers (status checks, amount validations)\n\n## Components and Interfaces\n\n### Component 1: PurchaseRequestWorkflowService\n\n**Purpose:** Orchestrates PR submission, approval, and rejection workflows with budget integration\n\n**Interfaces:**\n```typescript\ninterface IPurchaseRequestWorkflowService {\n  /**\n   * Submit PR for approval with budget validation and reservation\n   * @throws BudgetError if budget unavailable\n   * @throws ValidationError if PR status invalid\n   */\n  submit(prId: number, userId: number): Promise<PurchaseRequests>;\n\n  /**\n   * Approve PR and keep budget reservation\n   * @throws ForbiddenError if user not authorized\n   * @throws ValidationError if PR status invalid\n   */\n  approve(prId: number, approverId: number): Promise<PurchaseRequests>;\n\n  /**\n   * Reject PR and release budget reservation\n   * @throws ForbiddenError if user not authorized\n   * @throws ValidationError if PR status invalid\n   */\n  reject(prId: number, rejecterId: number, reason: string): Promise<PurchaseRequests>;\n}\n```\n\n**Dependencies:**\n- `PurchaseRequestsService` - For CRUD operations and status updates\n- `BudgetIntegrationService` - For budget checking, reservation, release\n- `NotificationService` - For sending approval notifications (optional)\n- `PrismaClient` - For transaction management\n\n**Reuses:**\n- Existing `PurchaseRequestsService` for findById, update\n- Existing `BaseService` validation hooks\n- Existing Prisma transaction pattern\n\n**Implementation Pattern:**\n```typescript\nexport class PurchaseRequestWorkflowService implements IPurchaseRequestWorkflowService {\n  constructor(\n    private prisma: PrismaClient,\n    private prService: PurchaseRequestsService,\n    private budgetIntegration: BudgetIntegrationService,\n    private logger: FastifyBaseLogger,\n  ) {}\n\n  async submit(prId: number, userId: number): Promise<PurchaseRequests> {\n    return this.prisma.$transaction(async (tx) => {\n      // 1. Validate PR status (must be DRAFT)\n      const pr = await this.prService.findById(prId);\n      if (!pr || pr.status !== 'DRAFT') {\n        throw new ValidationError('PR must be in DRAFT status to submit');\n      }\n\n      // 2. Check budget availability\n      const budgetCheck = await this.budgetIntegration.checkAvailability({\n        fiscal_year: pr.fiscal_year,\n        budget_type_id: pr.budget_id,\n        department_id: pr.department_id,\n        amount: pr.total_amount,\n        quarter: getCurrentQuarter(),\n      });\n\n      if (!budgetCheck.available) {\n        throw new BudgetError('Insufficient budget', {\n          available: budgetCheck.remaining,\n          requested: pr.total_amount,\n          shortage: pr.total_amount - budgetCheck.remaining,\n        });\n      }\n\n      // 3. Reserve budget\n      const reservation = await this.budgetIntegration.reserve({\n        allocation_id: budgetCheck.allocation_id,\n        pr_id: pr.id,\n        amount: pr.total_amount,\n        quarter: getCurrentQuarter(),\n        expires_days: 30,\n      });\n\n      // 4. Update PR status\n      const submitted = await this.prService.update(pr.id, {\n        status: 'SUBMITTED',\n        submitted_at: new Date(),\n        submitted_by: userId,\n      });\n\n      // 5. Send notification (non-blocking)\n      this.sendApprovalNotification(pr).catch(err =>\n        this.logger.error({ err, prId }, 'Failed to send approval notification')\n      );\n\n      return submitted;\n    });\n  }\n\n  // ... approve() and reject() methods\n}\n```\n\n---\n\n### Component 2: PurchaseOrderWorkflowService\n\n**Purpose:** Orchestrates PO approval, sending, and cancellation workflows with budget commitment\n\n**Interfaces:**\n```typescript\ninterface IPurchaseOrderWorkflowService {\n  /**\n   * Approve PO (validate approval documents for high-value POs)\n   * @throws ValidationError if approval document missing\n   */\n  approve(poId: number, approverId: number): Promise<PurchaseOrders>;\n\n  /**\n   * Send PO to vendor and commit budget\n   * @throws BudgetError if budget commitment fails\n   * @throws ValidationError if PO not approved\n   */\n  send(poId: number, userId: number): Promise<PurchaseOrders>;\n\n  /**\n   * Cancel PO and release budget commitment\n   * @throws ValidationError if PO has receipts\n   */\n  cancel(poId: number, userId: number, reason: string): Promise<PurchaseOrders>;\n}\n```\n\n**Dependencies:**\n- `PurchaseOrdersService` - For CRUD operations\n- `BudgetIntegrationService` - For budget commitment/release\n- `ContractPricingService` - For contract price lookup (used in creation)\n- `PurchaseRequestsService` - For updating linked PR status\n- `PrismaClient` - For transactions\n\n**Reuses:**\n- Existing PO service and repository\n- Budget integration patterns from PR workflow\n- Transaction management patterns\n\n---\n\n### Component 3: ReceiptWorkflowService\n\n**Purpose:** Orchestrates receipt posting with inventory updates and lot creation\n\n**Interfaces:**\n```typescript\ninterface IReceiptWorkflowService {\n  /**\n   * Post receipt to inventory (create lots, update stock)\n   * @throws ValidationError if inspectors < 3\n   * @throws ValidationError if receipt already posted\n   */\n  post(receiptId: number, userId: number): Promise<Receipts>;\n\n  /**\n   * Validate receipt before posting\n   * @returns validation errors or empty array\n   */\n  validateForPosting(receiptId: number): Promise<ValidationError[]>;\n}\n```\n\n**Dependencies:**\n- `ReceiptsService` - For CRUD operations\n- `InventoryIntegrationService` - For lot creation and stock updates\n- `PurchaseOrdersService` - For updating PO status\n- `PrismaClient` - For transactions\n\n**Reuses:**\n- Existing receipts service\n- Prisma upsert pattern for inventory\n\n**Implementation Pattern:**\n```typescript\nasync post(receiptId: number, userId: number): Promise<Receipts> {\n  return this.prisma.$transaction(async (tx) => {\n    // 1. Validate receipt\n    const receipt = await this.receiptsService.findById(receiptId);\n    const errors = await this.validateForPosting(receiptId);\n    if (errors.length > 0) {\n      throw new ValidationError('Receipt validation failed', errors);\n    }\n\n    // 2. Create drug lots\n    const lots = await this.inventoryIntegration.createLots(receipt, tx);\n\n    // 3. Update inventory\n    await this.inventoryIntegration.updateStock(receipt, tx);\n\n    // 4. Create inventory transactions\n    await this.inventoryIntegration.createTransactions(receipt, tx);\n\n    // 5. Update PO status\n    const poComplete = await this.checkPOComplete(receipt.po_id, tx);\n    await this.poService.update(receipt.po_id, {\n      status: poComplete ? 'COMPLETED' : 'PARTIAL',\n    });\n\n    // 6. Update receipt status\n    const posted = await this.receiptsService.update(receipt.id, {\n      status: 'POSTED',\n      posted_at: new Date(),\n      posted_by: userId,\n    });\n\n    return posted;\n  });\n}\n```\n\n---\n\n### Component 4: BudgetIntegrationService\n\n**Purpose:** Handle all Budget API interactions with retry logic and error handling\n\n**Interfaces:**\n```typescript\ninterface IBudgetIntegrationService {\n  /**\n   * Check if budget is available for requested amount\n   * @throws BudgetAPIError if API call fails\n   * @throws TimeoutError if API timeout\n   */\n  checkAvailability(params: BudgetCheckParams): Promise<BudgetCheckResult>;\n\n  /**\n   * Reserve budget for PR\n   * @throws BudgetAPIError if reservation fails\n   */\n  reserve(params: BudgetReserveParams): Promise<BudgetReservation>;\n\n  /**\n   * Commit budget for PO\n   * @throws BudgetAPIError if commit fails\n   */\n  commit(params: BudgetCommitParams): Promise<BudgetCommitment>;\n\n  /**\n   * Release budget reservation (PR rejected)\n   */\n  releaseReservation(reservationId: number): Promise<void>;\n\n  /**\n   * Release budget commitment (PO cancelled)\n   */\n  releaseCommitment(commitmentId: number): Promise<void>;\n}\n\ninterface BudgetCheckParams {\n  fiscal_year: number;\n  budget_type_id: number;\n  department_id: number;\n  amount: number;\n  quarter: number;\n}\n\ninterface BudgetCheckResult {\n  available: boolean;\n  allocation_id: number;\n  remaining: number;\n  reserved: number;\n  committed: number;\n}\n```\n\n**Dependencies:**\n- `HttpClientService` - For HTTP requests with retry\n- `ConfigService` - For Budget API base URL\n- `Logger` - For error logging\n\n**Reuses:**\n- Axios or Fetch for HTTP calls\n- Exponential backoff retry pattern\n\n**Error Handling Strategy:**\n```typescript\nasync checkAvailability(params: BudgetCheckParams): Promise<BudgetCheckResult> {\n  try {\n    const response = await this.httpClient.post('/api/budget/check-availability', params, {\n      timeout: 5000,\n      retries: 3,\n      retryDelay: (attempt) => Math.pow(2, attempt) * 1000, // 1s, 2s, 4s\n    });\n\n    return response.data;\n  } catch (error) {\n    if (error.code === 'ETIMEDOUT') {\n      throw new TimeoutError('Budget API timeout after 5s');\n    }\n    if (error.response?.status === 503) {\n      throw new BudgetAPIError('Budget API unavailable', error);\n    }\n    throw new BudgetAPIError('Budget check failed', error);\n  }\n}\n```\n\n---\n\n### Component 5: InventoryIntegrationService\n\n**Purpose:** Handle inventory updates, lot creation, and transaction logging\n\n**Interfaces:**\n```typescript\ninterface IInventoryIntegrationService {\n  /**\n   * Create drug lots from receipt items\n   */\n  createLots(receipt: Receipts, tx: PrismaTransaction): Promise<DrugLot[]>;\n\n  /**\n   * Update inventory stock levels\n   */\n  updateStock(receipt: Receipts, tx: PrismaTransaction): Promise<void>;\n\n  /**\n   * Create inventory transaction records\n   */\n  createTransactions(receipt: Receipts, tx: PrismaTransaction): Promise<void>;\n}\n```\n\n**Dependencies:**\n- `PrismaClient` - For database operations\n- `Logger` - For operation logging\n\n**Reuses:**\n- Prisma upsert pattern\n- Prisma transaction context\n\n**Implementation Pattern:**\n```typescript\nasync createLots(receipt: Receipts, tx: PrismaTransaction): Promise<DrugLot[]> {\n  const receiptItems = await tx.receiptItem.findMany({\n    where: { receipt_id: receipt.id },\n    include: { generic: { include: { drugs: true } } },\n  });\n\n  const lots = [];\n  for (const item of receiptItems) {\n    if (item.quantity_accepted > 0) {\n      const lot = await tx.drugLot.create({\n        data: {\n          lot_number: item.lot_number,\n          drug_id: item.generic.drugs[0].id, // Get first trade drug\n          location_id: receipt.location_id,\n          quantity: item.quantity_accepted,\n          quantity_remaining: item.quantity_accepted,\n          unit_cost: item.unit_price,\n          manufacture_date: item.manufacture_date,\n          expiry_date: item.expiry_date,\n          received_date: receipt.receipt_date,\n          receipt_id: receipt.id,\n        },\n      });\n      lots.push(lot);\n    }\n  }\n\n  return lots;\n}\n\nasync updateStock(receipt: Receipts, tx: PrismaTransaction): Promise<void> {\n  const receiptItems = await tx.receiptItem.findMany({\n    where: { receipt_id: receipt.id },\n    include: { generic: { include: { drugs: true } } },\n  });\n\n  for (const item of receiptItems) {\n    if (item.quantity_accepted > 0) {\n      await tx.inventory.upsert({\n        where: {\n          drug_id_location_id: {\n            drug_id: item.generic.drugs[0].id,\n            location_id: receipt.location_id,\n          },\n        },\n        create: {\n          drug_id: item.generic.drugs[0].id,\n          location_id: receipt.location_id,\n          quantity_on_hand: item.quantity_accepted,\n          unit_cost: item.unit_price,\n          last_updated: new Date(),\n        },\n        update: {\n          quantity_on_hand: { increment: item.quantity_accepted },\n          last_updated: new Date(),\n        },\n      });\n    }\n  }\n}\n```\n\n---\n\n### Component 6: ContractPricingService\n\n**Purpose:** Lookup contract prices with Redis caching for performance\n\n**Interfaces:**\n```typescript\ninterface IContractPricingService {\n  /**\n   * Get contract price for drug from vendor\n   * @returns agreed price or null if no contract\n   */\n  getContractPrice(vendorId: number, genericId: number): Promise<number | null>;\n\n  /**\n   * Get all contract prices for PO creation\n   */\n  getContractPricesForPO(vendorId: number, genericIds: number[]): Promise<Map<number, number>>;\n\n  /**\n   * Clear cache for vendor contracts (when contract updated)\n   */\n  clearCache(vendorId: number): Promise<void>;\n}\n```\n\n**Dependencies:**\n- `ContractsService` - For contract queries\n- `Redis` - For caching\n- `PrismaClient` - For database queries\n\n**Reuses:**\n- Existing contracts service\n- Redis caching pattern\n\n**Caching Strategy:**\n```typescript\nasync getContractPrice(vendorId: number, genericId: number): Promise<number | null> {\n  const cacheKey = `contract:price:${vendorId}:${genericId}`;\n\n  // Try cache first\n  const cached = await this.redis.get(cacheKey);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Query database\n  const contractItem = await this.prisma.contractItem.findFirst({\n    where: {\n      contract: {\n        vendor_id: vendorId,\n        status: 'ACTIVE',\n        start_date: { lte: new Date() },\n        end_date: { gte: new Date() },\n      },\n      generic_id: genericId,\n    },\n    select: { agreed_unit_price: true },\n  });\n\n  const price = contractItem?.agreed_unit_price?.toNumber() || null;\n\n  // Cache for 1 hour\n  await this.redis.setex(cacheKey, 3600, JSON.stringify(price));\n\n  return price;\n}\n```\n\n## Data Models\n\n### Workflow State Models\n\n**PurchaseRequest Workflow States:**\n```typescript\nenum PRStatus {\n  DRAFT = 'DRAFT',           // Initial state\n  SUBMITTED = 'SUBMITTED',   // After budget reservation\n  APPROVED = 'APPROVED',     // After approval, ready for PO\n  REJECTED = 'REJECTED',     // Rejected, budget released\n  CONVERTED = 'CONVERTED',   // Converted to PO\n}\n\ninterface PurchaseRequests {\n  id: number;\n  pr_number: string;\n  department_id: number;\n  budget_id: number;\n  fiscal_year: number;\n  total_amount: Decimal;\n  status: PRStatus;\n\n  // Workflow timestamps\n  submitted_at?: Date;\n  submitted_by?: number;\n  approved_at?: Date;\n  approved_by?: number;\n  rejected_at?: Date;\n  rejected_by?: number;\n  rejection_reason?: string;\n}\n```\n\n**PurchaseOrder Workflow States:**\n```typescript\nenum POStatus {\n  DRAFT = 'DRAFT',          // Initial state\n  PENDING = 'PENDING',      // Awaiting approval\n  APPROVED = 'APPROVED',    // Approved, ready to send\n  SENT = 'SENT',            // Sent to vendor, budget committed\n  PARTIAL = 'PARTIAL',      // Partially received\n  COMPLETED = 'COMPLETED',  // Fully received\n  CANCELLED = 'CANCELLED',  // Cancelled\n}\n\ninterface PurchaseOrders {\n  id: number;\n  po_number: string;\n  pr_id: number;\n  vendor_id: number;\n  contract_id?: number;\n  grand_total: Decimal;\n  status: POStatus;\n\n  // Workflow timestamps\n  approved_at?: Date;\n  approved_by?: number;\n  sent_date?: Date;\n}\n```\n\n**Receipt Workflow States:**\n```typescript\nenum ReceiptStatus {\n  DRAFT = 'DRAFT',          // Initial state\n  INSPECTING = 'INSPECTING', // Under inspection\n  ACCEPTED = 'ACCEPTED',    // Accepted, ready to post\n  POSTED = 'POSTED',        // Posted to inventory\n  REJECTED = 'REJECTED',    // Rejected\n}\n\ninterface Receipts {\n  id: number;\n  receipt_number: string;\n  po_id: number;\n  location_id: number;\n  status: ReceiptStatus;\n\n  // Workflow timestamps\n  inspected_at?: Date;\n  inspected_by?: number;\n  posted_at?: Date;\n  posted_by?: number;\n}\n```\n\n### Integration Data Models\n\n**Budget API Request/Response Models:**\n```typescript\ninterface BudgetCheckRequest {\n  fiscal_year: number;\n  budget_type_id: number;\n  department_id: number;\n  amount: number;\n  quarter: number;\n}\n\ninterface BudgetCheckResponse {\n  available: boolean;\n  allocation_id: number;\n  allocated: number;\n  reserved: number;\n  committed: number;\n  remaining: number;\n}\n\ninterface BudgetReserveRequest {\n  allocation_id: number;\n  pr_id: number;\n  amount: number;\n  quarter: number;\n  expires_days: number;\n}\n\ninterface BudgetReserveResponse {\n  reservation_id: number;\n  expires_date: Date;\n}\n```\n\n**Inventory Models (existing database):**\n```typescript\ninterface DrugLot {\n  id: number;\n  lot_number: string;\n  drug_id: number;\n  location_id: number;\n  quantity: number;\n  quantity_remaining: number;\n  unit_cost: Decimal;\n  manufacture_date: Date;\n  expiry_date: Date;\n  received_date: Date;\n  receipt_id: number;\n}\n\ninterface Inventory {\n  id: number;\n  drug_id: number;\n  location_id: number;\n  quantity_on_hand: number;\n  unit_cost: Decimal;\n  last_updated: Date;\n}\n\ninterface InventoryTransaction {\n  id: number;\n  drug_id: number;\n  location_id: number;\n  transaction_type: 'RECEIVE' | 'DISPENSE' | 'ADJUST';\n  quantity: number;\n  unit_cost: Decimal;\n  reference_type: 'RECEIPT' | 'DISPENSATION';\n  reference_id: number;\n  transaction_date: Date;\n  performed_by: number;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n#### 1. Budget Unavailable\n- **Scenario**: User submits PR but department budget is insufficient\n- **Handling**:\n  - `BudgetIntegrationService.checkAvailability()` returns `{available: false}`\n  - Throw `BudgetError` with shortage details\n  - Transaction rollback (PR status remains DRAFT)\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"งบประมาณไม่เพียงพอ (Insufficient budget)\"\n  - Details: `{available: 10000, requested: 15000, shortage: 5000}`\n  - User can reduce amount or request budget increase\n\n#### 2. Budget API Timeout\n- **Scenario**: Budget API takes > 5 seconds to respond\n- **Handling**:\n  - `HttpClientService` throws `TimeoutError` after 5s\n  - Retry 3 times with exponential backoff (1s, 2s, 4s)\n  - If all retries fail, throw `BudgetAPIError`\n  - Transaction rollback\n- **User Impact**:\n  - HTTP 503 Service Unavailable\n  - Error message: \"Budget service temporarily unavailable. Please try again.\"\n  - Retry button in UI\n\n#### 3. Invalid PR Status for Submission\n- **Scenario**: User tries to submit PR that is already SUBMITTED or APPROVED\n- **Handling**:\n  - `PurchaseRequestWorkflowService.submit()` validates status\n  - Throw `ValidationError` with current status\n  - No database changes\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"Cannot submit PR in APPROVED status\"\n  - UI disables submit button for non-DRAFT PRs\n\n#### 4. Unauthorized Approval Attempt\n- **Scenario**: User without approve permission tries to approve PR\n- **Handling**:\n  - Fastify `verifyPermission('procurement:pr:approve')` hook rejects request\n  - Throw `ForbiddenError`\n  - No database changes\n- **User Impact**:\n  - HTTP 403 Forbidden\n  - Error message: \"You don't have permission to approve purchase requests\"\n  - UI hides approve button for unauthorized users\n\n#### 5. Missing Approval Document for High-Value PO\n- **Scenario**: User tries to approve PO > 100,000 without approval document\n- **Handling**:\n  - `PurchaseOrderWorkflowService.approve()` checks `approval_documents` table\n  - Throw `ValidationError` with required document types\n  - No status update\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"Approval document required for PO > 100,000 baht\"\n  - UI prompts user to upload document\n\n#### 6. Insufficient Inspectors for Receipt Posting\n- **Scenario**: User tries to post receipt with only 2 inspectors (need 3)\n- **Handling**:\n  - `ReceiptWorkflowService.validateForPosting()` checks `receipt_inspectors` count\n  - Throw `ValidationError` with current count\n  - No posting occurs\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"Minimum 3 inspectors required (current: 2)\"\n  - UI shows inspector list and allows adding more\n\n#### 7. Receipt Quantity Exceeds PO Quantity\n- **Scenario**: User records received quantity > ordered quantity\n- **Handling**:\n  - Schema validation catches this in `receiptItems` creation\n  - Throw `ValidationError` with quantities\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"Received quantity (1000) exceeds ordered quantity (500)\"\n  - UI validates on input and shows warning\n\n#### 8. Database Transaction Failure During Receipt Posting\n- **Scenario**: Inventory update fails midway through posting\n- **Handling**:\n  - Prisma transaction automatically rolls back all changes\n  - `ReceiptWorkflowService.post()` re-throws error\n  - Log full error with receipt ID\n- **User Impact**:\n  - HTTP 500 Internal Server Error\n  - Error message: \"Failed to post receipt. Please try again.\"\n  - Receipt remains in ACCEPTED status, user can retry\n\n#### 9. PO Cancellation with Existing Receipts\n- **Scenario**: User tries to cancel PO that has receipts\n- **Handling**:\n  - `PurchaseOrderWorkflowService.cancel()` checks for related receipts\n  - Throw `ValidationError` with receipt count\n  - No cancellation occurs\n- **User Impact**:\n  - HTTP 400 Bad Request\n  - Error message: \"Cannot cancel PO with existing receipts (3 receipts found)\"\n  - UI shows receipts list and suggests voiding receipts first\n\n#### 10. Expired Budget Reservation\n- **Scenario**: PR was created 35 days ago, reservation expired (30-day limit)\n- **Handling**:\n  - Background job auto-releases expired reservations\n  - On PR approval attempt, check if reservation exists\n  - If expired, re-reserve budget before approval\n- **User Impact**:\n  - Transparent to user if budget still available\n  - If budget now unavailable: HTTP 400 with shortage details\n\n### Error Response Format\n\n**Standard Error Response:**\n```typescript\n{\n  success: false,\n  error: {\n    code: string,              // 'INSUFFICIENT_BUDGET', 'VALIDATION_ERROR', etc.\n    message: string,           // Thai message\n    message_en: string,        // English message\n    details?: any,             // Additional context\n    statusCode: number,        // HTTP status code\n    timestamp: string,         // ISO 8601 timestamp\n    path: string,              // Request path\n    correlationId: string,     // For log tracing\n  }\n}\n```\n\n**Example Error Response:**\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"INSUFFICIENT_BUDGET\",\n    \"message\": \"งบประมาณไม่เพียงพอ\",\n    \"message_en\": \"Insufficient budget\",\n    \"details\": {\n      \"available\": 10000,\n      \"requested\": 15000,\n      \"shortage\": 5000,\n      \"fiscal_year\": 2025,\n      \"quarter\": 2\n    },\n    \"statusCode\": 400,\n    \"timestamp\": \"2025-04-15T09:30:00.000Z\",\n    \"path\": \"/api/inventory/procurement/purchase-requests/123/submit\",\n    \"correlationId\": \"req_abc123\"\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach:**\n- Test each service method in isolation with mocked dependencies\n- Use Jest for test framework\n- Mock Prisma client, external services, logger\n- Target: 80%+ code coverage\n\n**Key Components to Test:**\n\n1. **PurchaseRequestWorkflowService**\n   - ✅ `submit()` with successful budget check\n   - ✅ `submit()` with insufficient budget (should throw)\n   - ✅ `submit()` with invalid status (should throw)\n   - ✅ `approve()` with valid PR\n   - ✅ `approve()` without permission (should throw)\n   - ✅ `reject()` and verify budget release\n\n2. **BudgetIntegrationService**\n   - ✅ `checkAvailability()` successful response\n   - ✅ `checkAvailability()` timeout with retries\n   - ✅ `reserve()` successful reservation\n   - ✅ `commit()` successful commitment\n   - ✅ `releaseReservation()` successful release\n\n3. **InventoryIntegrationService**\n   - ✅ `createLots()` creates correct lot records\n   - ✅ `updateStock()` upserts inventory correctly\n   - ✅ `createTransactions()` records all transactions\n\n**Example Unit Test:**\n```typescript\ndescribe('PurchaseRequestWorkflowService', () => {\n  let service: PurchaseRequestWorkflowService;\n  let mockPrisma: MockPrismaClient;\n  let mockBudgetService: MockBudgetIntegrationService;\n  let mockPRService: MockPurchaseRequestsService;\n\n  beforeEach(() => {\n    mockPrisma = createMockPrisma();\n    mockBudgetService = createMockBudgetService();\n    mockPRService = createMockPRService();\n    service = new PurchaseRequestWorkflowService(\n      mockPrisma,\n      mockPRService,\n      mockBudgetService,\n      mockLogger,\n    );\n  });\n\n  describe('submit()', () => {\n    it('should submit PR with budget reservation', async () => {\n      // Arrange\n      const pr = { id: 1, status: 'DRAFT', total_amount: 10000 };\n      mockPRService.findById.mockResolvedValue(pr);\n      mockBudgetService.checkAvailability.mockResolvedValue({\n        available: true,\n        allocation_id: 1,\n        remaining: 50000,\n      });\n      mockBudgetService.reserve.mockResolvedValue({ reservation_id: 1 });\n      mockPRService.update.mockResolvedValue({ ...pr, status: 'SUBMITTED' });\n\n      // Act\n      const result = await service.submit(1, 100);\n\n      // Assert\n      expect(result.status).toBe('SUBMITTED');\n      expect(mockBudgetService.checkAvailability).toHaveBeenCalledWith({\n        fiscal_year: pr.fiscal_year,\n        budget_type_id: pr.budget_id,\n        department_id: pr.department_id,\n        amount: 10000,\n        quarter: expect.any(Number),\n      });\n      expect(mockBudgetService.reserve).toHaveBeenCalled();\n    });\n\n    it('should throw BudgetError if insufficient budget', async () => {\n      // Arrange\n      mockPRService.findById.mockResolvedValue({ id: 1, status: 'DRAFT', total_amount: 60000 });\n      mockBudgetService.checkAvailability.mockResolvedValue({\n        available: false,\n        remaining: 50000,\n      });\n\n      // Act & Assert\n      await expect(service.submit(1, 100)).rejects.toThrow(BudgetError);\n      expect(mockBudgetService.reserve).not.toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### Integration Testing\n\n**Approach:**\n- Test full workflow endpoints with real database (test DB)\n- Use Fastify's `inject()` method for HTTP testing\n- Setup/teardown database between tests\n- Mock only external dependencies (Budget API)\n\n**Key Flows to Test:**\n\n1. **PR Submission Flow**\n   ```typescript\n   it('POST /purchase-requests/:id/submit - success with budget', async () => {\n     // 1. Create PR in DRAFT status\n     const pr = await createTestPR({ status: 'DRAFT', total_amount: 10000 });\n\n     // 2. Mock Budget API\n     mockBudgetAPI.onPost('/check-availability').reply(200, { available: true });\n     mockBudgetAPI.onPost('/reserve').reply(200, { reservation_id: 1 });\n\n     // 3. Submit PR\n     const response = await app.inject({\n       method: 'POST',\n       url: `/api/inventory/procurement/purchase-requests/${pr.id}/submit`,\n       headers: { authorization: `Bearer ${token}` },\n     });\n\n     // 4. Verify\n     expect(response.statusCode).toBe(200);\n     expect(response.json().data.status).toBe('SUBMITTED');\n\n     // 5. Verify database\n     const updated = await prisma.purchaseRequest.findUnique({ where: { id: pr.id } });\n     expect(updated.status).toBe('SUBMITTED');\n     expect(updated.submitted_at).toBeDefined();\n   });\n   ```\n\n2. **Complete Procurement Cycle**\n   ```typescript\n   it('Full cycle: PR → Approve → PO → Send → Receipt → Post', async () => {\n     // 1. Create and submit PR\n     const pr = await createAndSubmitPR();\n\n     // 2. Approve PR\n     await approvePR(pr.id);\n\n     // 3. Create PO from PR\n     const po = await createPOFromPR(pr.id);\n\n     // 4. Approve and send PO\n     await approveAndSendPO(po.id);\n\n     // 5. Create receipt\n     const receipt = await createReceipt(po.id);\n\n     // 6. Add inspectors\n     await addInspectors(receipt.id, [inspector1, inspector2, inspector3]);\n\n     // 7. Post receipt\n     const posted = await postReceipt(receipt.id);\n\n     // 8. Verify inventory updated\n     const inventory = await prisma.inventory.findFirst({\n       where: { drug_id: testDrugId, location_id: testLocationId },\n     });\n     expect(inventory.quantity_on_hand).toBeGreaterThan(0);\n\n     // 9. Verify lots created\n     const lots = await prisma.drugLot.findMany({\n       where: { receipt_id: receipt.id },\n     });\n     expect(lots.length).toBeGreaterThan(0);\n   });\n   ```\n\n### End-to-End Testing\n\n**Approach:**\n- Use Playwright or Cypress for browser automation\n- Test complete user workflows through UI\n- Use staging environment with real Budget API\n\n**User Scenarios to Test:**\n\n1. **Pharmacist creates and submits PR**\n   - Navigate to PR list\n   - Click \"Create PR\"\n   - Select drugs and quantities\n   - See budget check in real-time\n   - Submit for approval\n   - Verify notification sent to manager\n\n2. **Manager approves PR**\n   - Login as manager\n   - Navigate to pending PRs\n   - Review PR details\n   - Approve PR\n   - Verify requester notified\n\n3. **Procurement officer creates PO**\n   - Navigate to approved PRs\n   - Click \"Create PO\"\n   - System auto-fills from PR\n   - Select vendor\n   - System applies contract prices\n   - Send PO to vendor\n\n4. **Warehouse staff records receipt**\n   - Navigate to sent POs\n   - Click \"Record Receipt\"\n   - Enter lot numbers and expiry dates\n   - Inspect and accept items\n   - Add inspector committee\n   - Post to inventory\n   - Verify stock levels updated\n\n**E2E Test Example:**\n```typescript\ntest('Complete procurement workflow', async ({ page }) => {\n  // 1. Login as pharmacist\n  await page.goto('/login');\n  await page.fill('[name=\"username\"]', 'pharmacist1');\n  await page.fill('[name=\"password\"]', 'password');\n  await page.click('button[type=\"submit\"]');\n\n  // 2. Create PR\n  await page.goto('/procurement/purchase-requests');\n  await page.click('button:has-text(\"Create PR\")');\n  await page.selectOption('[name=\"department\"]', 'Pharmacy');\n  await page.selectOption('[name=\"budget\"]', 'OP001');\n\n  // Add drug\n  await page.click('button:has-text(\"Add Drug\")');\n  await page.fill('[name=\"drug_search\"]', 'Paracetamol');\n  await page.click('.drug-item:first-child');\n  await page.fill('[name=\"quantity\"]', '5000');\n\n  // Submit\n  await page.click('button:has-text(\"Submit for Approval\")');\n\n  // Verify success\n  await expect(page.locator('.alert-success')).toContainText('PR submitted');\n\n  // 3. Login as manager and approve\n  await page.goto('/logout');\n  await loginAs('manager1');\n  await page.goto('/procurement/pending-approvals');\n  await page.click('.pr-item:first-child .approve-button');\n  await expect(page.locator('.alert-success')).toContainText('PR approved');\n\n  // ... continue with PO creation, receipt, etc.\n});\n```\n\n## Deployment Considerations\n\n### Environment Variables\n\n```env\n# Budget API Configuration\nBUDGET_API_URL=http://localhost:3384/api/budget\nBUDGET_API_TIMEOUT=5000\nBUDGET_API_RETRY_ATTEMPTS=3\n\n# Redis Configuration (for contract caching)\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\nREDIS_DB=0\n\n# Procurement Configuration\nPROCUREMENT_PR_APPROVAL_LEVELS=2\nPROCUREMENT_PO_HIGH_VALUE_THRESHOLD=100000\nPROCUREMENT_RECEIPT_MIN_INSPECTORS=3\nPROCUREMENT_BUDGET_RESERVATION_DAYS=30\n\n# Notification Configuration\nNOTIFICATION_EMAIL_ENABLED=true\nSMTP_HOST=smtp.gmail.com\nSMTP_PORT=587\nSMTP_USER=\nSMTP_PASSWORD=\n```\n\n### Database Migrations\n\nNo new tables needed (all tables already exist). Only add indexes for performance:\n\n```sql\n-- Optimize PR workflow queries\nCREATE INDEX idx_purchase_requests_status_dept ON purchase_requests(status, department_id);\nCREATE INDEX idx_purchase_requests_fiscal_year ON purchase_requests(fiscal_year);\n\n-- Optimize PO workflow queries\nCREATE INDEX idx_purchase_orders_status_date ON purchase_orders(status, po_date);\nCREATE INDEX idx_purchase_orders_vendor ON purchase_orders(vendor_id);\n\n-- Optimize receipt queries\nCREATE INDEX idx_receipts_status_date ON receipts(status, receipt_date);\nCREATE INDEX idx_receipt_items_lot ON receipt_items(lot_number);\n\n-- Optimize contract pricing lookups\nCREATE INDEX idx_contract_items_vendor_generic ON contract_items(contract_id, generic_id);\nCREATE INDEX idx_contracts_vendor_status ON contracts(vendor_id, status, start_date, end_date);\n```\n\n### Monitoring and Observability\n\n**Metrics to Track:**\n- Average PR approval time\n- Budget API response time and error rate\n- Receipt posting success rate\n- Inventory update failures\n- Contract cache hit rate\n\n**Logging Strategy:**\n```typescript\n// Structured logging with context\nrequest.log.info({\n  userId: request.user.id,\n  prId: 123,\n  action: 'submit_pr',\n  amount: 15000,\n  fiscal_year: 2025,\n  duration: 245, // ms\n}, 'PR submitted successfully');\n\n// Error logging\nrequest.log.error({\n  err,\n  userId: request.user.id,\n  prId: 123,\n  action: 'submit_pr',\n  budgetCheckParams: { ... },\n}, 'Budget check failed');\n```\n\n**Health Check Endpoint:**\n```typescript\nGET /api/inventory/procurement/health\n{\n  status: 'healthy',\n  checks: {\n    database: 'ok',\n    budget_api: 'ok',\n    redis: 'ok',\n  },\n  uptime: 3600,\n  version: '1.0.0'\n}\n```\n",
  "fileStats": {
    "size": 45608,
    "lines": 1436,
    "lastModified": "2025-12-14T13:11:57.688Z"
  },
  "comments": []
}